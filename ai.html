<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gomega AI — ai.html (local)</title>

<!-- In-page /api override (must be first) -->
<script>
(function(){
  const origFetch = window.fetch.bind(window);

  // ----------- persistent local state --------------
  const PKEY = 'gomega_local_state_v4';
  // session state (cleared on 2h reset) is stored separately
  const SESSION_KEY = 'gomega_session_v4';

  const DEFAULT = {
    key: "local-key-123456",
    learn: true,
    models: [
      { id: 'gomega-2.o', label: 'gomega-2.o (concise)' },
      { id: 'gomega-3.o', label: 'gomega-3.o (conservative)' },
      { id: 'gomega-4.o', label: 'gomega-4.o (balanced)' },
      { id: 'gomega-5.o', label: 'gomega-5.o (beta)' },
      { id: 'gomega-6.o', label: 'gomega-6.o (creative)' },
      { id: 'gomega-7.o', label: 'gomega-7.o (developer)' }
    ],
    // system knowledge that the assistant can reference
    systemKnowledge: `
You are Gomega AI — a local assistant running inside the user's browser.
Name: Gomega AI
Identity: GPT-5 Thinking mini (for direct "what model are you" questions).
Purpose: Help the user with coding, ideas, local testing, and remembering short facts locally.
Memory policy: Store meaningful user/assistant turns for retrieval. Do not store tiny greetings.
Limits: Chat session resets every 2 hours, but long-term memories persist unless the user clears them.
Knowledge: Use local heuristics and stored memories; do not call external servers.
    `.trim()
  };

  // load persistent state
  let LOCAL = Object.assign({}, DEFAULT);
  try {
    const raw = localStorage.getItem(PKEY);
    if(raw) {
      Object.assign(LOCAL, JSON.parse(raw));
      // ensure defaults exist
      LOCAL.models = LOCAL.models || DEFAULT.models;
      LOCAL.systemKnowledge = LOCAL.systemKnowledge || DEFAULT.systemKnowledge;
    } else {
      LOCAL = Object.assign({}, DEFAULT);
    }
  } catch(e) { console.warn('load state err', e); }

  // session state (history) with start timestamp
  let SESSION = { startedAt: Date.now(), history: [] }; // history: [{role,content,ts}]
  try {
    const rawS = localStorage.getItem(SESSION_KEY);
    if(rawS) SESSION = JSON.parse(rawS);
  } catch(e){ console.warn('load session err', e); }

  function persist() {
    try { localStorage.setItem(PKEY, JSON.stringify(LOCAL)); }
    catch(e){ console.warn('persist err', e); }
  }
  function persistSession() {
    try { localStorage.setItem(SESSION_KEY, JSON.stringify(SESSION)); }
    catch(e){ console.warn('persist session err', e); }
  }

  // ----------- text utilities & simple vector retrieval --------------
  const STOP = new Set([
    'the','is','in','on','and','a','an','of','to','for','i','you','me','it','that','this','with','are','was',
    'be','have','has','do','did','not','but','my','your','we','they','he','she','as','at','by','from','or','if'
  ]);
  function tokenize(s){
    if(!s) return [];
    return String(s).toLowerCase().replace(/[^a-z0-9\s]/g,' ').split(/\s+/).filter(w=>w.length>2 && !STOP.has(w));
  }

  // build TF map
  function tfMap(tokens){
    const m = Object.create(null);
    for(const t of tokens) m[t] = (m[t]||0)+1;
    return m;
  }

  function idfMap(docs){
    const df = Object.create(null);
    for(const d of docs){
      const seen = new Set(Object.keys(d));
      for(const k of seen) df[k] = (df[k]||0)+1;
    }
    const idf = Object.create(null);
    const N = docs.length || 1;
    for(const k in df) idf[k] = Math.log(1 + N/(df[k]||1));
    return idf;
  }

  function dot(a,b,idf){
    let s = 0;
    for(const k in a){
      if(!b[k]) continue;
      const ai = a[k], bi = b[k];
      const w = idf && idf[k] ? idf[k] : 1;
      s += ai * bi * w * w;
    }
    return s;
  }

  function norm(v,idf){
    let s = 0;
    for(const k in v){
      const w = idf && idf[k] ? idf[k] : 1;
      s += (v[k]*w)*(v[k]*w);
    }
    return Math.sqrt(s || 1);
  }

  // extract keywords and tf map for storage
  function analyzeText(text){
    const tokens = tokenize(text);
    const tf = tfMap(tokens);
    return { tokens, tf };
  }

  // store memory: ensure keywords & tf
  LOCAL.memories = LOCAL.memories || []; // each: {role,text,ts,tokens,tf}
  function storeMemory(role,text){
    if(!LOCAL.learn) return;
    const txt = String(text || '').trim();
    if(!txt) return;
    // skip tiny greetings
    if(txt.length < 30 && /^(hi|hello|hey|how are you|what's up|sup)$/i.test(txt)) return;
    const a = analyzeText(txt);
    LOCAL.memories.push({ role, text: txt, ts: Date.now(), tokens: a.tokens, tf: a.tf });
    if(LOCAL.memories.length > 2500) LOCAL.memories = LOCAL.memories.slice(-2500);
    persist();
  }

  // smart retrieval: build idf across memories on the fly and compute cosine-like similarity
  function retrieveRelevant(query, topN=6){
    if(!LOCAL.memories.length) return [];
    const qTokens = tokenize(query);
    const qTF = tfMap(qTokens);
    // build docs tf list
    const docsTF = LOCAL.memories.map(m => m.tf || {});
    const idf = idfMap(docsTF.concat([qTF]));
    const qNorm = norm(qTF, idf);
    const scored = LOCAL.memories.map(m => {
      const sc = dot(qTF, m.tf || {}, idf) / (qNorm * norm(m.tf || {}, idf) || 1);
      return { m, score: sc || 0 };
    });
    scored.sort((a,b)=>b.score-a.score);
    return scored.filter(s=>s.score>0.03).slice(0,topN);
  }

  // slight paraphrase helper
  function paraphraseShort(text){
    const templates = [
      `I remember: ${text}`,
      `From earlier: ${text}`,
      `${text} — want more detail?`
    ];
    return templates[Math.floor(Math.random()*templates.length)];
  }

  // system knowledge fetch
  function systemInfo(){
    return LOCAL.systemKnowledge || DEFAULT.systemKnowledge;
  }

  // ----------------- generator (smarter) -----------------
  // Note: must answer "what model are you" EXACTLY with "GPT-5 Thinking mini" somewhere
  function localGenerate(messages, temperature=0.7, modelId='gomega-4.o', thinkMode=false){
    // find last user content
    let lastUser = "";
    for(let i=messages.length-1;i>=0;i--) if(messages[i].role==='user'){ lastUser = messages[i].content||''; break; }
    const q = String(lastUser || '').trim();
    const lq = q.toLowerCase();

    // direct helpers
    if(/\bwhat model (are you|is this)\b|\bwhich model (are you|is this)\b/i.test(lq)){
      // required identity string
      return `I am GPT-5 Thinking mini, running as Gomega AI (local).`;
    }
    if(/\bwhat model am i using\b|\bwhich model am i using\b/i.test(lq)){
      return modelId ? `You're using **${modelId}** right now.` : `You're using the local model chosen in the UI.`;
    }
    if(/\bwho are you\b|\bwhat are you\b/i.test(lq)){
      return `I am Gomega AI — a local assistant running in your browser. I keep local memories and follow the system knowledge. (Identity: GPT-5 Thinking mini)`;
    }
    if(/\bdate\b|\btoday\b/i.test(lq) && /\bwhat\b|\bwhich\b|^\b/.test(lq)){
      return `Today is ${new Date().toDateString()}.`;
    }
    if(/\btime\b/i.test(lq) && /\bwhat\b|current/i.test(lq)){
      return `Current time: ${new Date().toLocaleTimeString()}.`;
    }

    // built-in greeting & small talk
    if(/^(hi|hello|hey|hiya|sup)[\!\.\s]*$/i.test(q)){
      const msgs = ["Hey — I'm Gomega AI. How can I help?", "Hi! Gomega AI here. What would you like to do today?", "Hello — ready to help. Ask me something!"];
      return msgs[Math.floor(Math.random()*msgs.length)];
    }
    if(/\bhow (are|is) (you|your day)\b|\bhow's your day\b/i.test(lq)){
      return ["I'm ready and running locally — how's your day?", "Doing well — ready to help you with code, ideas, or memory."][Math.floor(Math.random()*2)];
    }

    // memory search shortcut
    if(lq.startsWith('search memory:')) {
      const term = q.slice(14).trim();
      if(!term) return 'Provide a term after "search memory:".';
      const hits = retrieveRelevant(term, 12);
      if(!hits.length) return 'No memories matched that query.';
      return 'Memory matches:\n\n' + hits.map(h => `${h.m.role.toUpperCase()} (${new Date(h.m.ts).toLocaleString()}): ${h.m.text.slice(0,280)}`).join('\n\n');
    }

    // remember: explicit
    if(lq.startsWith('remember:')) {
      const note = q.slice(9).trim();
      if(!note) return 'Say remember: <text> to store something.';
      // store handled by fetch wrapper; just ack
      return `Okay — I'll remember: ${note.slice(0,180)}`;
    }

    // if thinkMode is enabled, make the assistant wait longer and be more elaborate
    const t = Math.max(0, Math.min(1, Number(temperature) || 0.7));
    const thinkingBoost = thinkMode ? 0.6 : 0;

    // retrieval from memories (TF-IDF style)
    const hits = retrieveRelevant(q, 8);
    if(hits.length && hits[0].score > 0.12 - (0.05 * thinkingBoost)){ // require stronger match
      const best = hits[0].m;
      if(best.role === 'assistant' && best.text && best.text.length > 20 && !best.text.toLowerCase().includes(q.toLowerCase())){
        // reuse/paraphrase
        return paraphraseShort(best.text);
      }
      // else synthesise combination
      const combined = hits.map(h=>h.m.text).join('\n\n');
      // keep it concise or elaborate depending on temperature + thinkMode
      if(t + thinkingBoost > 0.8) {
        return `Combining relevant notes:\n\n${combined.split('\n').slice(0,6).join('\n')}\n\nWould you like this expanded or summarized?`;
      } else {
        const s = hits[0].m.text.split(/[.\n]/).filter(Boolean)[0] || hits[0].m.text;
        return `Related memory: ${s.slice(0,300)}`;
      }
    }

    // fallback synthesis: attempt to produce structured help for pattern questions
    if(/\bhow to\b|\bhow do i\b|\bexplain\b|\bexample\b|\bcreate\b|\bbuild\b/i.test(lq)){
      // create a steps list
      const steps = [
        `1) Clarify the goal and constraints.`,
        `2) Break the problem into smaller tasks.`,
        `3) Provide a short example or sample code.`,
        `4) Test and iterate.`,
        `5) Summarize next steps.`
      ];
      if(t + thinkingBoost > 0.7) {
        return `Here's a structured approach:\n\n${steps.join('\n')}\n\nTell me which step to expand on.`;
      } else {
        return `Start by clarifying the goal, then break it down into small tasks. Ask me for an example if you want code.`;
      }
    }

    // fallback canned replies (vary with temperature/personality)
    const personalities = {
      '2.o': 0.2, '3.o': 0.35, '4.o': 0.6, '5.o': 0.9, '6.o': 1.2, '7.o': 1.4
    };
    const pers = personalities[modelId] || 0.6;
    const idx = Math.floor(Math.random() * 3 * (0.4 + t * pers)) % 3;
    const canned = [
      `I understood: "${q}". Could you add more detail so I can answer precisely?`,
      `Local reply to "${q}" — I can provide steps, examples or a summary. Which would you prefer?`,
      `Quick thought: "${q}" — I can expand this into a step-by-step guide if you like.`
    ][idx];

    // for think mode, be slightly more helpful
    if(thinkMode && Math.random() < 0.6) {
      return canned + `\n\n(Thinking mode: I considered related memories and system knowledge.)`;
    }
    return canned;
  }

  // ----------------- fetch override -----------------
  window.fetch = async function(input, init){
    try {
      const urlStr = (typeof input === 'string') ? input : (input && input.url) || '';
      const parsed = new URL(urlStr, location.href);
      const pathname = parsed.pathname || '/';
      if(pathname.startsWith('/api')){
        await new Promise(r=>setTimeout(r, 40 + Math.random()*200));
        const sub = pathname.slice('/api'.length) || '/';

        // GET /api/config
        if((sub === '/' || sub === '' || sub === '/config') && (!init || (init.method||'GET').toUpperCase()==='GET')){
          return new Response(JSON.stringify({ models: LOCAL.models, provider: 'local', premiumAvailable: false, learn: !!LOCAL.learn, systemKnowledge: LOCAL.systemKnowledge }), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // GET /api/key
        if(sub === '/key' && (!init || (init.method||'GET').toUpperCase()==='GET')){
          return new Response(JSON.stringify({ key: LOCAL.key }), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // GET /api/memories
        if(sub === '/memories' && (!init || (init.method||'GET').toUpperCase()==='GET')){
          return new Response(JSON.stringify({ memories: LOCAL.memories.map(m=>({ role:m.role, text:m.text, ts:m.ts })) }), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // POST /api/clear-memories
        if(sub === '/clear-memories' && init && (init.method||'').toUpperCase() === 'POST'){
          LOCAL.memories = []; persist();
          return new Response(JSON.stringify({ ok:true }), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // POST /api/chat
        if(sub === '/chat' && init && (init.method||'').toUpperCase() === 'POST'){
          let body = {};
          try { body = JSON.parse(init.body || '{}'); } catch(e){}
          const messages = body.messages || [];
          const temperature = Number(body.temperature || 0.7);
          const modelId = body.modelId || (LOCAL.models[2] && LOCAL.models[2].id);
          const thinkMode = !!body.thinkMode;

          // store user memory (not tiny greetings)
          try {
            const lastUser = messages.slice().reverse().find(m=>m.role==='user');
            if(lastUser && lastUser.content){
              const txt = String(lastUser.content).trim();
              const tiny = txt.length < 30 && /^(hi|hello|hey|how are you|what's up)$/i.test(txt);
              if(!tiny) storeMemory('user', txt);
            }
          } catch(e){ console.warn('store user err', e); }

          // generate reply
          const reply = localGenerate(messages, temperature, modelId, thinkMode);

          // store assistant memory (if useful)
          if(reply && reply.length > 20) storeMemory('assistant', reply);

          return new Response(JSON.stringify({ text: reply, model: modelId }), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // Not found
        return new Response('Not found', { status:404, headers:{'Content-Type':'text/plain'} });
      }
    } catch(e){ console.warn('fetch override err', e); }
    return origFetch(input, init);
  };

  // expose small debug
  window.__GOMEGA_LOCAL = {
    getState: () => JSON.parse(JSON.stringify(LOCAL)),
    persist, storeMemory,
    resetSession: ()=>{ SESSION = { startedAt: Date.now(), history: [] }; persistSession(); },
    getSession: ()=> JSON.parse(JSON.stringify(SESSION)),
    persistSession
  };
})();
</script>

<!-- UI libs -->
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<style>
  :root{
    --bg:#071026;
    --card:#071427;
    --muted:#94a3b8;
  }
  html,body{height:100%;background:linear-gradient(180deg,#041226 0%, #071026 100%); color:#e6eef8; font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  .container{max-width:1100px;margin:24px auto;padding:16px;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); border-radius:14px; padding:14px;}
  .model-badge{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03);font-size:12px;color:var(--muted);border:1px solid rgba(255,255,255,0.03);}
  .msg{display:flex;gap:12px;align-items:flex-start;}
  .avatar{width:40px;height:40px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:700;}
  .u{background:linear-gradient(90deg,#4f46e5,#ec4899); color:white;}
  .g{background:linear-gradient(90deg,#06b6d4,#7c3aed); color:white;}
  .bubble{background:rgba(255,255,255,0.02);border-radius:10px;padding:10px;max-width:78%;}
  .meta{font-size:12px;color:var(--muted);}
  .typing-cursor{display:inline-block;width:8px;height:14px;background:currentColor;border-radius:2px;animation:blink 1s steps(2,start) infinite;margin-left:6px;vertical-align:middle;}
  @keyframes blink{50%{opacity:0}}
  .think-dots span{display:inline-block;width:6px;height:6px;border-radius:999px;margin:0 3px;background:var(--muted);opacity:0.25;animation:think 1s infinite;}
  .think-dots span:nth-child(1){animation-delay:0s}
  .think-dots span:nth-child(2){animation-delay:0.15s}
  .think-dots span:nth-child(3){animation-delay:0.3s}
  @keyframes think{0%{transform:translateY(0);opacity:0.2}50%{transform:translateY(-6px);opacity:1}100%{transform:translateY(0);opacity:0.2}}
  .scrollarea{max-height:56vh; overflow:auto; padding-right:6px;}
  .controls input[type="range"]{vertical-align:middle}
  .small{font-size:12px;color:var(--muted);}
  .reset-timer{font-weight:600;color:#93c5fd}
  .topbar{display:flex;gap:12px;align-items:center;justify-content:space-between;}
  .leftcol{display:flex;gap:12px;align-items:center;}
  .rightcol{display:flex;gap:8px;align-items:center;}
  .pill{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:999px;border:1px solid rgba(255,255,255,0.03);font-size:13px;}
  .footer-note{font-size:12px;color:var(--muted);text-align:center;margin-top:12px;}
</style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="topbar">
        <div class="leftcol">
          <div style="width:48px;height:48px;border-radius:12px;background:linear-gradient(90deg,#7c3aed,#06b6d4);display:flex;align-items:center;justify-content:center;font-weight:800;font-size:18px">GA</div>
          <div>
            <div style="font-weight:700;font-size:18px">Gomega AI <span class="small" style="font-weight:500">— local assistant</span></div>
            <div class="small" id="subtitle">Identity: GPT-5 Thinking mini • Local only</div>
          </div>
        </div>

        <div class="rightcol">
          <div class="pill small">Session resets every 2 hours</div>
          <div class="pill small">Session timer: <span id="sessionTimer" class="reset-timer">--:--:--</span></div>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 300px;gap:14px;margin-top:14px;">
        <!-- chat column -->
        <div class="card" style="padding:12px;">
          <div id="chatArea" class="scrollarea"></div>

          <form id="composer" style="margin-top:12px;display:flex;gap:8px;align-items:flex-end;">
            <textarea id="prompt" rows="2" placeholder="Ask anything… (commands: /reset /memories search memory: remember: )" style="flex:1;background:rgba(255,255,255,0.02);border-radius:10px;padding:10px;border:1px solid rgba(255,255,255,0.03);color:inherit;"></textarea>
            <div style="display:flex;flex-direction:column;gap:8px;">
              <button id="send" type="submit" style="background:#7c3aed;padding:8px 12px;border-radius:10px;border:none;color:white;font-weight:700;">Send</button>
              <button id="resetNow" type="button" style="background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:8px;color:var(--muted);">Reset Now</button>
            </div>
          </form>

          <div style="display:flex;justify-content:space-between;margin-top:10px;align-items:center;">
            <div class="small">Chat limit: <span id="chatLimitDisplay">200 messages</span> • Memories persisted separately</div>
            <div class="small">Think mode: <label style="margin-left:6px"><input id="thinkToggle" type="checkbox"> on</label></div>
          </div>
        </div>

        <!-- side column -->
        <div style="display:flex;flex-direction:column;gap:10px;">
          <div class="card" style="padding:12px;">
            <div style="font-weight:700;margin-bottom:8px">Model & Settings</div>
            <div style="display:flex;flex-direction:column;gap:8px;">
              <label class="small">Model
                <select id="modelSelect" style="width:100%;margin-top:6px;background:transparent;border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.04);">
                </select>
              </label>

              <label class="small">Temperature <span id="tempVal">0.7</span>
                <input id="tempRange" type="range" min="0" max="2" step="0.1" value="0.7" style="width:100%;display:block;margin-top:6px;">
              </label>

              <label class="small">Typing speed (ms/char) <span id="speedVal">18</span>
                <input id="speedRange" type="range" min="4" max="60" step="1" value="18" style="width:100%;display:block;margin-top:6px;">
              </label>

              <div style="display:flex;gap:8px;">
                <button id="viewMem" class="pill" style="flex:1">View memories</button>
                <button id="clearMem" class="pill" style="flex:1">Clear memories</button>
              </div>

              <div style="display:flex;gap:8px;margin-top:8px;">
                <button id="exportMem" class="pill" style="flex:1">Export</button>
                <label class="pill" style="flex:1;cursor:pointer"><input id="importFile" type="file" accept="application/json" style="display:none"> Import</label>
              </div>
            </div>
          </div>

          <div class="card" style="padding:12px;">
            <div style="font-weight:700;margin-bottom:8px">Session & Info</div>
            <div class="small">Started: <span id="sessStart">--</span></div>
            <div class="small">History messages: <span id="histCount">0</span></div>
            <div style="margin-top:8px;" class="small">System knowledge: (used to shape replies)</div>
            <pre id="sysInfo" style="background:rgba(0,0,0,0.15);padding:8px;border-radius:6px;max-height:120px;overflow:auto;font-size:12px;">...</pre>
          </div>

          <div class="card" style="padding:12px;">
            <div style="font-weight:700;margin-bottom:8px">Shortcuts</div>
            <div class="small">/reset — clear chat history session</div>
            <div class="small">/memories — open memories viewer</div>
            <div class="small">search memory: &lt;term&gt; — quick find</div>
            <div class="small">remember: &lt;text&gt; — explicitly store a memory</div>
          </div>
        </div>
      </div>

      <div class="footer-note">This runs locally in your browser. No external servers are called. Identity string for direct queries: <strong>GPT-5 Thinking mini</strong>.</div>
    </div>
  </div>

  <!-- memories modal -->
  <div id="modal" style="position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:50;">
    <div style="width:90%;max-width:900px;background:var(--card);border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03);">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div style="font-weight:700">Memories</div>
        <div><input id="memSearch" placeholder="search..." style="background:transparent;border:1px solid rgba(255,255,255,0.03);padding:6px;border-radius:8px;color:inherit"><button id="closeMem" style="margin-left:8px;" class="pill">Close</button></div>
      </div>
      <div id="memList" style="margin-top:12px;max-height:60vh;overflow:auto;"></div>
    </div>
  </div>

<script>
/* ---------- UI + client logic ---------- */
const $ = (s, p=document)=>p.querySelector(s);
const chatArea = $('#chatArea'), promptEl = $('#prompt'), form = $('#composer'), sendBtn = $('#send'),
      modelSelect = $('#modelSelect'), tempRange = $('#tempRange'), tempVal = $('#tempVal'),
      speedRange = $('#speedRange'), speedVal = $('#speedVal'), thinkToggle = $('#thinkToggle'),
      sessionTimer = $('#sessionTimer'), sessStartEl = $('#sessStart'), histCount = $('#histCount'),
      sysInfo = $('#sysInfo'), viewMem = $('#viewMem'), modal = $('#modal'), memList = $('#memList'),
      closeMem = $('#closeMem'), memSearch = $('#memSearch'), exportMem = $('#exportMem'),
      importFile = $('#importFile'), clearMem = $('#clearMem'), resetNow = $('#resetNow'), chatLimitDisplay = $('#chatLimitDisplay');

let CHAT_LIMIT = 200;
let SESSION_RESET_MS = 1000 * 60 * 60 * 2; // 2 hours
let typingSpeed = Number(speedRange.value); // ms per char
let temp = Number(tempRange.value);
let thinkMode = thinkToggle.checked;
let currentModel = null;

// initial load config from local api
async function loadConfig(){
  try{
    const r = await fetch('/api/config', { cache: 'no-store' });
    const cfg = r.ok ? await r.json() : {};
    const models = cfg.models || [{id:'gomega-4.o',label:'gomega-4.o'}];
    modelSelect.innerHTML = '';
    for(const m of models){ const o = document.createElement('option'); o.value = m.id; o.textContent = m.label||m.id; modelSelect.appendChild(o); }
    currentModel = modelSelect.value;
    temp = tempRange.value = cfg.temperature || temp;
    tempVal.textContent = tempRange.value;
    sysInfo.textContent = (cfg.systemKnowledge || '').slice(0,2000);
    // show initial session info
    updateSessionUI();
  }catch(e){ console.warn('loadConfig err', e); }
}
loadConfig();

// session & history kept in localStorage by internal fetch override; provide local mirror
function getSession(){
  try{ return JSON.parse(localStorage.getItem('gomega_session_v4') || JSON.stringify({ startedAt: Date.now(), history: [] })); }
  catch(e){ return { startedAt: Date.now(), history: [] }; }
}
function setSession(s){ localStorage.setItem('gomega_session_v4', JSON.stringify(s)); }

function nowISO(ts) { return new Date(ts).toLocaleString(); }

function addMessageToSession(role, content){
  const s = getSession();
  s.history.push({ role, content, ts: Date.now() });
  // trim
  if(s.history.length > CHAT_LIMIT) s.history = s.history.slice(-CHAT_LIMIT);
  setSession(s);
  updateSessionUI();
}

function updateSessionUI(){
  const s = getSession();
  sessStartEl.textContent = nowISO(s.startedAt);
  histCount.textContent = (s.history || []).length;
  chatLimitDisplay.textContent = CHAT_LIMIT + ' messages';
  // compute time until reset
  const elapsed = Date.now() - (s.startedAt || Date.now());
  const remain = Math.max(0, SESSION_RESET_MS - elapsed);
  sessionTimer.textContent = msToHMS(remain);
  // if expired, reset session automatically
  if(remain <= 0){
    resetSession();
  }
}

function msToHMS(ms){
  const s = Math.floor(ms/1000);
  const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), sec = s % 60;
  return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
}

// periodical timer
setInterval(updateSessionUI, 1000);

// reset session: clears session history and UI only
function resetSession(){
  const s = { startedAt: Date.now(), history: [] };
  setSession(s);
  // clear chat UI
  chatArea.innerHTML = '';
  updateSessionUI();
  alert('Session reset: chat history cleared (2-hour limit). Memories are kept unless you clear them.');
}

// restore session messages to UI
function renderSessionUI(){
  chatArea.innerHTML = '';
  const s = getSession();
  for(const m of s.history){
    appendMessageToUI(m.role, m.content, m.ts);
  }
}
renderSessionUI();

// append static message (not streaming)
function appendMessageToUI(role, content, ts){
  const wrap = document.createElement('div');
  wrap.className = 'msg';
  const avatar = document.createElement('div');
  avatar.className = 'avatar ' + (role==='user' ? 'u' : 'g');
  avatar.textContent = role==='user' ? 'U' : 'G';
  const bubble = document.createElement('div');
  bubble.className = 'bubble';
  bubble.innerHTML = marked.parseInline(content) || content;
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = ts ? new Date(ts).toLocaleString() : '';
  const container = document.createElement('div');
  container.appendChild(bubble);
  container.appendChild(meta);
  wrap.appendChild(avatar);
  wrap.appendChild(container);
  chatArea.appendChild(wrap);
  chatArea.scrollTop = chatArea.scrollHeight;
}

// create a typing element for assistant with streaming simulation
function appendAssistantTypingElement(){
  const wrap = document.createElement('div');
  wrap.className = 'msg';
  const avatar = document.createElement('div');
  avatar.className = 'avatar g';
  avatar.textContent = 'G';
  const bubble = document.createElement('div');
  bubble.className = 'bubble';
  // think area first (invisible unless think mode)
  const thinkDiv = document.createElement('div');
  thinkDiv.className = 'think-dots';
  thinkDiv.innerHTML = '<span></span><span></span><span></span>';
  thinkDiv.style.marginBottom = '6px';
  bubble.appendChild(thinkDiv);
  const textEl = document.createElement('div');
  textEl.style.whiteSpace = 'pre-wrap';
  bubble.appendChild(textEl);
  const meta = document.createElement('div'); meta.className = 'meta';
  meta.textContent = '';
  const container = document.createElement('div');
  container.appendChild(bubble);
  container.appendChild(meta);
  wrap.appendChild(avatar);
  wrap.appendChild(container);
  chatArea.appendChild(wrap);
  chatArea.scrollTop = chatArea.scrollHeight;
  return { wrap, textEl, thinkDiv, meta };
}

// streaming type-out: returns a promise resolved when finished
function streamTypeInto(element, text, speed){
  return new Promise(resolve=>{
    let i = 0;
    element.textContent = '';
    const step = ()=>{
      if(i >= text.length){ resolve(); return; }
      element.textContent += text[i++];
      chatArea.scrollTop = chatArea.scrollHeight;
      setTimeout(step, speed);
    };
    step();
  });
}

// high-level send flow
form.addEventListener('submit', async (e)=>{
  e.preventDefault();
  const content = promptEl.value.trim();
  if(!content) return;

  // commands
  if(content === '/reset'){ resetSession(); promptEl.value=''; return; }
  if(content === '/memories'){ openMemViewer(); promptEl.value=''; return; }
  if(content.toLowerCase().startsWith('remember:')){
    // store explicit memory by sending to /api/chat (server stores it)
    const note = content.slice(9).trim();
    if(note){
      await fetch('/api/chat', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ messages:[{role:'user', content:`remember: ${note}`}], temperature: 0.2, modelId: modelSelect.value })});
      alert('Saved note to memories.');
    } else alert('Provide text after remember:');
    promptEl.value=''; return;
  }

  // push user msg to session & UI
  addMessageToSession('user', content);
  appendMessageToUI('user', content, Date.now());
  promptEl.value = '';
  // prepare assistant placeholder
  const typingNode = appendAssistantTypingElement();
  // call /api/chat
  sendBtn.disabled = true;
  try{
    const payload = { messages: getSession().history.slice(-180), temperature: Number(tempRange.value), modelId: modelSelect.value, thinkMode: thinkToggle.checked };
    // call local API
    const resp = await fetch('/api/chat', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
    if(!resp.ok){
      typingNode.textEl.textContent = `**Error: server ${resp.status}**`;
      sendBtn.disabled = false;
      return;
    }
    const j = await resp.json();
    const reply = j.text || String(j);
    // show think animation for a short while if thinkMode enabled
    const thinkDelay = thinkToggle.checked ? 600 + Math.random()*1200 : 80 + Math.random()*260;
    // show the dots (already shown), wait then type
    await new Promise(r=>setTimeout(r, thinkDelay));
    // remove dots area
    typingNode.thinkDiv.style.display = 'none';
    // simulated typing
    typingSpeed = Number(speedRange.value);
    await streamTypeInto(typingNode.textEl, reply, typingSpeed);
    // set meta
    typingNode.meta.textContent = `model: ${j.model || modelSelect.value}`;
    // commit to session store
    addMessageToSession('assistant', reply);
  }catch(err){
    console.error('chat err', err);
    typingNode.textEl.textContent = '**Error:** ' + (err.message || String(err));
  }finally{
    sendBtn.disabled = false;
  }
});

// helper to add to session store and keep UI counts
function addMessageToSession(role, content){
  const s = getSession();
  s.history.push({ role, content, ts: Date.now() });
  if(s.history.length > CHAT_LIMIT) s.history = s.history.slice(-CHAT_LIMIT);
  setSession(s);
  histCount.textContent = s.history.length;
}

// event handlers for settings
modelSelect.addEventListener('change', ()=> currentModel = modelSelect.value);
tempRange.addEventListener('input', ()=> tempVal.textContent = tempRange.value);
speedRange.addEventListener('input', ()=> speedVal.textContent = speedRange.value);
thinkToggle.addEventListener('change', ()=> thinkMode = thinkToggle.checked);
resetNow.addEventListener('click', ()=> { if(confirm('Reset now?')) resetSession(); });

// memory viewer
function openMemViewer(){
  modal.style.display = 'flex';
  renderMemList();
}
viewMem.addEventListener('click', openMemViewer);
closeMem.addEventListener('click', ()=> modal.style.display = 'none');

async function renderMemList(query=''){
  memList.innerHTML = '';
  try {
    const r = await fetch('/api/memories');
    if(!r.ok) throw new Error('failed');
    const j = await r.json();
    const arr = (j.memories || []).slice().reverse();
    const frag = document.createDocumentFragment();
    for(const m of arr){
      if(query && !m.text.toLowerCase().includes(query.toLowerCase())) continue;
      const div = document.createElement('div');
      div.className = 'card';
      div.style.marginBottom = '8px';
      div.style.padding = '8px';
      div.innerHTML = `<div style="font-size:12px;color:var(--muted)">${m.role.toUpperCase()} • ${new Date(m.ts).toLocaleString()}</div><div style="margin-top:6px">${marked.parseInline(m.text)}</div>`;
      frag.appendChild(div);
    }
    memList.appendChild(frag);
  } catch(e){ memList.textContent = 'Failed to load memories.'; }
}
memSearch.addEventListener('input', ()=> renderMemList(memSearch.value));

// export/import/clear memories
exportMem.addEventListener('click', async ()=>{
  try{
    const r = await fetch('/api/memories');
    if(!r.ok) throw new Error('export failed');
    const j = await r.json();
    const blob = new Blob([JSON.stringify(j.memories || [], null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `gomega-memories-${new Date().toISOString().slice(0,10)}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }catch(e){ alert('Export failed'); }
});

importFile.addEventListener('change', async (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  try{
    const txt = await f.text();
    const arr = JSON.parse(txt);
    if(!Array.isArray(arr)) throw new Error('expected array');
    // merge by calling internal storeMemory via /api? we will push into local storage directly for speed:
    const st = (await fetch('/api/memories').then(r=>r.ok?r.json():{memories:[]}).catch(()=>({memories:[]}))).memories || [];
    const merged = (st.concat(arr)).slice(-2000);
    // store merged by writing to local storage persistence key (note: internal state is saved under gomega_local_state_v4 by the override)
    const stateRaw = JSON.parse(localStorage.getItem('gomega_local_state_v4') || '{}');
    stateRaw.memories = merged.map(m=>({ role:m.role||'assistant', text:m.text||m, ts:m.ts||Date.now(), tokens:[], tf:{} }));
    localStorage.setItem('gomega_local_state_v4', JSON.stringify(stateRaw));
    alert('Imported memories. Reload page to refresh.');
  }catch(e){ alert('Import failed: '+(e.message||e)); }
  ev.target.value = '';
});

clearMem.addEventListener('click', async ()=>{
  if(!confirm('Clear all memories permanently?')) return;
  try{
    const r = await fetch('/api/clear-memories', { method:'POST' });
    if(!r.ok) throw new Error('clear failed');
    alert('Memories cleared.');
  }catch(e){ alert('Failed to clear memories'); }
});

// load initial model selection & system info periodically
(async function init(){
  await loadConfig();
  // refresh sys info periodically
  setInterval(async ()=>{
    const r = await fetch('/api/config', {cache:'no-store'}).catch(()=>null);
    if(r && r.ok){ const j = await r.json(); sysInfo.textContent = (j.systemKnowledge || '').slice(0,2000); }
  }, 60000);
})();

// auto reset session every 2 hours handled by updateSessionUI interval
// and manual reset button available

// expose helper for dev
window.GOMEGA_UI = { resetSession, getSession: ()=>getSession(), renderSessionUI };

</script>
</body>
</html>
