<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gomega AI — ai.html (local)</title>
<style>
  :root{
    --bg-1: #eaf8ff;
    --bg-2: #dff4ff;
    --card: rgba(255,255,255,0.95);
    --muted: #4b6b7a;
    --accent1:#4f46e5;
    --accent2:#06b6d4;
    --glass: rgba(11,37,64,0.06);
    --glass-2: rgba(11,37,64,0.03);
    --text: #072033;
    --bubble-bg-user: linear-gradient(90deg,#7c3aed,#ec4899);
    --bubble-bg-assistant: linear-gradient(90deg,var(--accent2),var(--accent1));
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-1) 0%, var(--bg-2) 100%);color:var(--text);font-family:Inter,system-ui,Roboto,Arial,sans-serif}
  .container{max-width:1200px;margin:18px auto;padding:18px;transition:all .18s ease;}
  .card{background:var(--card);border-radius:14px;border:1px solid var(--glass);padding:14px;box-shadow:0 8px 30px rgba(11,37,64,0.06)}
  .top{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .brand{display:flex;align-items:center;gap:12px}
  .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(90deg,var(--accent1),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:900;font-size:18px;color:white;box-shadow:0 8px 28px rgba(6,182,212,0.12);transition:transform .3s ease}
  .logo.floating{animation:floaty 6s infinite ease-in-out;}
  @keyframes floaty{0%{transform:none}50%{transform:translateY(-6px)}100%{transform:none}}
  .title{font-weight:800;font-size:18px}
  .subtitle{font-size:13px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:14px;margin-top:14px}
  .chat-col .scroll{max-height:66vh;overflow:auto;padding-right:8px;display:flex;flex-direction:column;gap:12px}
  .msg{display:flex;gap:12px;align-items:flex-start;opacity:0;transform:translateY(8px);animation:fadeIn .22s forwards}
  @keyframes fadeIn { to{opacity:1;transform:none} }
  .avatar{width:44px;height:44px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:700;color:white}
  .avatar.user{background:var(--bubble-bg-user);box-shadow:0 8px 18px rgba(124,58,237,0.12)}
  .avatar.g{background:var(--bubble-bg-assistant);box-shadow:0 8px 18px rgba(6,182,212,0.12)}
  .msg-wrap{display:flex;flex-direction:column}
  .bubble{background:rgba(255,255,255,0.98);border-radius:12px;padding:12px;max-width:78%;box-shadow:0 6px 18px rgba(11,37,64,0.05);transition:transform .12s, box-shadow .12s;color:var(--text);border:1px solid var(--glass-2)}
  .bubble.ghost{opacity:.9;filter:grayscale(.02);border-style:dashed;background:linear-gradient(180deg, rgba(250,250,250,0.98), rgba(245,249,255,0.98))}
  .bubble pre, .bubble code{color:var(--text);background:transparent}
  .bubble a{color:var(--accent1);text-decoration:underline}
  .meta{font-size:12px;color:var(--muted);margin-top:8px}
  .composer{display:flex;gap:10px;align-items:flex-end;margin-top:12px}
  textarea{flex:1;background:transparent;border-radius:12px;padding:12px;border:1px solid var(--glass);color:var(--text);min-height:60px;resize:vertical;outline:none;transition:box-shadow .12s, transform .08s}
  textarea:focus{box-shadow:0 8px 24px rgba(6,182,212,0.08);transform:translateY(-2px)}
  textarea[disabled]{opacity:0.6;cursor:not-allowed}
  button{font-weight:700;border-radius:10px;padding:8px 12px;border:none;cursor:pointer}
  .send{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:white;box-shadow:0 10px 24px rgba(7,10,30,0.06);transition:transform .14s ease}
  .send:hover{transform:translateY(-4px)}
  .pill{background:rgba(15,140,74,0.05);padding:6px 8px;border-radius:999px;border:1px solid var(--glass);font-size:13px;color:var(--text)}
  .side .card{padding:12px}
  .small{font-size:12px;color:var(--muted)}
  .tools{display:flex;gap:8px;flex-wrap:wrap}
  .tool{padding:8px;border-radius:10px;border:1px solid var(--glass);background:rgba(255,255,255,0.95);cursor:pointer;transition:transform .12s, box-shadow .12s}
  .tool:hover{transform:translateY(-6px);box-shadow:0 12px 26px rgba(11,37,64,0.06)}
  .suggestions{display:flex;flex-direction:column;gap:8px;margin-top:12px}
  .suggestion{background:linear-gradient(180deg, rgba(255,255,255,0.98), rgba(245,249,255,0.98));padding:8px;border-radius:8px;border:1px solid var(--glass);cursor:pointer;transition:transform .12s}
  .suggestion:hover{transform:translateY(-4px)}
  .typing-dot{display:inline-block;width:6px;height:6px;margin:0 2px;background:rgba(7,10,30,0.12);border-radius:50%;animation:typing 1s infinite}
  @keyframes typing{0%{opacity:.2;transform:translateY(0)}50%{opacity:1;transform:translateY(-6px)}100%{opacity:.2;transform:translateY(0)}}
  .msg-enter{animation:msgPop .24s ease}
  @keyframes msgPop{0%{transform:translateY(8px) scale(.995);opacity:0}100%{transform:none;opacity:1}}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} .side{order:2} }
</style>
</head>
<body>
  <div class="container">
    <div class="card top">
      <div class="brand">
        <div class="logo floating">GA</div>
        <div>
          <div class="title">Gomega AI <span class="small">— local assistant</span></div>
          <div class="subtitle" id="subtitle">Identity: GPT-5 Thinking mini • Local only</div>
        </div>
      </div>
      <div style="display:flex;gap:10px;align-items:center">
        <div class="pill" id="modelBadge">Model: gomega-4.o</div>
        <div class="pill">Chats left: <span id="chatLimitDisplay">80</span></div>
      </div>
    </div>

    <div class="grid">
      <div class="card chat-col">
        <div class="scroll" id="chatArea"></div>

        <form id="composer" class="composer" autocomplete="off">
          <textarea id="prompt" placeholder="Ask anything… (commands: /memories /reset /remember: /search memory:)"></textarea>
          <div style="display:flex;flex-direction:column;gap:8px;">
            <button id="send" class="send" type="submit">Send</button>
            <button id="resetNow" type="button" class="pill">Reset Chat</button>
          </div>
        </form>

        <div class="strip">
          <div class="small">Modes:
            <label style="margin-left:8px"><input id="thinkToggle" type="checkbox"> Thinking</label>
            <label style="margin-left:8px"><input id="expertToggle" type="checkbox"> Expert (web)</label>
          </div>
          <div class="small">Memory: persistent • Local-only</div>
        </div>

        <div style="margin-top:12px;">
          <div style="font-weight:700">Quick actions</div>
          <div class="tools" style="margin-top:8px">
            <div class="tool" id="openCalc">Calculator</div>
            <div class="tool" id="openSafeRun">Safe Runner</div>
            <div class="tool" id="openRegex">Regex Tester</div>
            <div class="tool" id="openMemViewerBtn">Memories</div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <div style="font-weight:700">Tips & Examples</div>
          <div class="suggestions">
            <div class="suggestion" data-q="What games are on gomega.watch/schoolgames?">What games are on gomega.watch/schoolgames?</div>
            <div class="suggestion" data-q="Show me music resources at gomega.watch/music">Show me music resources at gomega.watch/music</div>
            <div class="suggestion" data-q="Do you have Roblox scripts? gomega.watch/scripts">Do you have Roblox scripts?</div>
            <div class="suggestion" data-q="Help me with a small HTML/CSS bug">Help me with a small HTML/CSS bug</div>
          </div>
        </div>
      </div>

      <div class="side">
        <div class="card">
          <div style="font-weight:700">Model & Settings</div>
          <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px;">
            <label class="small">Model
              <select id="modelSelect" style="width:100%;margin-top:6px;background:transparent;border-radius:8px;padding:8px;border:1px solid var(--glass);"></select>
            </label>
            <label class="small">Profile
              <select id="profileSelect" style="width:100%;margin-top:6px;background:transparent;border-radius:8px;padding:8px;border:1px solid var(--glass);"></select>
            </label>

            <div style="display:flex;gap:8px;margin-top:6px;">
              <button id="viewMem" class="pill" style="flex:1">View memories</button>
              <button id="clearMem" class="pill" style="flex:1">Clear memories</button>
            </div>

            <div style="display:flex;gap:8px;margin-top:8px;">
              <button id="exportMem" class="pill" style="flex:1">Export</button>
              <label class="pill" style="flex:1;cursor:pointer"><input id="importFile" type="file" accept="application/json" style="display:none"> Import</label>
            </div>
          </div>
        </div>

        <div class="card">
          <div style="font-weight:700">Session & Stats</div>
          <div class="small" style="margin-top:6px">Started: <span id="sessStart">--</span></div>
          <div class="small">Messages: <span id="histCount">0</span></div>
          <div style="margin-top:8px" class="small">System knowledge</div>
          <pre id="sysInfo" style="max-height:120px;overflow:auto;background:rgba(240,248,255,0.7);padding:8px;border-radius:8px;">...</pre>
        </div>

        <div class="card">
          <div style="font-weight:700">About gomega.watch</div>
          <div class="small" style="margin-top:8px">
            Gomega.watch — contains School Games, Music, Scripts, and more.
          </div>
        </div>

      </div>
    </div>

    <div class="footer">This runs locally. Identity string: <strong>GPT-5 Thinking mini</strong>.</div>
  </div>

  <!-- modal skeletons (same as earlier) -->
  <div id="modal" style="position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(7,10,30,0.08);z-index:80">
    <div style="width:92%;max-width:900px;background:var(--card);border-radius:12px;padding:14px;border:1px solid var(--glass);">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">Memories</div>
        <div><input id="memSearch" placeholder="search..." style="background:transparent;border:1px solid var(--glass);padding:6px;border-radius:8px;color:var(--text)"><button id="closeMem" class="pill" style="margin-left:8px">Close</button></div>
      </div>
      <div id="memList" style="margin-top:12px;max-height:60vh;overflow:auto"></div>
    </div>
  </div>

<script>
/* ===========================
   Utilities / UI helpers
   =========================== */
function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function mdInline(s){
  if(s==null) return '';
  let out = escapeHtml(s);
  out = out.replace(/`([^`]+)`/g,(m,p)=>'<code>'+escapeHtml(p)+'</code>');
  out = out.replace(/\*\*([^*]+)\*\*/g,(m,p)=>'<strong>'+escapeHtml(p)+'</strong>');
  out = out.replace(/(https?:\/\/[^\s<]+)/g,(m)=>`<a href="${m}" target="_blank" rel="noopener noreferrer">${m}</a>`);
  out = out.replace(/\n/g,'<br>');
  return out;
}

const $ = (s,p=document)=>p.querySelector(s);
const chatArea = $('#chatArea'), promptEl = $('#prompt'), form = $('#composer'), sendBtn = $('#send'),
      modelSelect = $('#modelSelect'), profileSelect = $('#profileSelect'), thinkToggle = $('#thinkToggle'), expertToggle = $('#expertToggle'),
      sessionStart = $('#sessStart'), histCount = $('#histCount'), sysInfo = $('#sysInfo'),
      viewMem = $('#viewMem'), modal = $('#modal'), memList = $('#memList'), closeMem = $('#closeMem'), memSearch = $('#memSearch'),
      exportMem = $('#exportMem'), importFile = $('#importFile'), clearMem = $('#clearMem'),
      openCalc = $('#openCalc'), calcModal = $('#calcModal'), calcInput = $('#calcInput'), calcRun = $('#calcRun'), calcOut = $('#calcOut'), closeCalc = $('#closeCalc'),
      openSafeRun = $('#openSafeRun'), safeRunModal = $('#safeRunModal'), safeCode = $('#safeCode'), safeRun = $('#safeRun'), safeOut = $('#safeOut'), closeSafeRun = $('#closeSafeRun'),
      openRegex = $('#openRegex'), openMemViewerBtn = $('#openMemViewerBtn'), resetNow = $('#resetNow'), chatLimitDisplay = $('#chatLimitDisplay'),
      modelBadge = $('#modelBadge');

const LS_SESSION = 'gomega_session_v9';
const LS_STATE = 'gomega_local_state_v9';
const MAX_SESSION_HISTORY = 200;   // cap session stored items
const MIN_SESSION_HISTORY = 8;     // minimal kept when trimming
let IN_MEMORY_SESSION = null;      // fallback in-memory session (kept even if localStorage full)
let CHAT_LIMIT = 80;               // chat limit as requested

/* ===========================
   Safe localStorage wrapper
   - setSession now trims and retries when quota exceeded
   - addMessage uses in-memory-first so UI never blocks
   =========================== */
function getSession(){
  try{
    const raw = localStorage.getItem(LS_SESSION);
    if(raw){
      const parsed = JSON.parse(raw);
      IN_MEMORY_SESSION = parsed; // sync into memory
      return parsed;
    }
  }catch(e){
    // ignore parse issues
  }
  if(IN_MEMORY_SESSION) return IN_MEMORY_SESSION;
  const s = { startedAt: Date.now(), history: [] };
  IN_MEMORY_SESSION = s;
  return s;
}

function setSession(session){
  // update in-memory always
  IN_MEMORY_SESSION = session;
  // try to persist to localStorage, but handle quota gracefully
  try{
    localStorage.setItem(LS_SESSION, JSON.stringify(session));
    return true;
  }catch(err){
    // If quota exceeded, progressively trim history and retry
    try{
      if(!session || !session.history) return false;
      // Trim strategy: remove oldest half until we can save or we reach MIN_SESSION_HISTORY
      let attempts = 0;
      while(attempts < 6){
        attempts++;
        if(session.history.length > MIN_SESSION_HISTORY){
          // remove oldest 25% each attempt
          const removeCount = Math.max(1, Math.floor(session.history.length * 0.25));
          session.history = session.history.slice(removeCount);
        } else {
          // if still failing, just keep minimal recent items
          session.history = session.history.slice(-MIN_SESSION_HISTORY);
        }
        try{
          localStorage.setItem(LS_SESSION, JSON.stringify(session));
          IN_MEMORY_SESSION = session;
          return true;
        }catch(e2){
          // continue trimming
        }
      }
    }catch(inner){
      // swallow
    }
    // if we couldn't persist, just keep it in memory (no throw)
    console.warn('localStorage setSession failed, using in-memory session fallback', err && err.message);
    return false;
  }
}

/* Append to session in-memory first; then attempt persist asynchronously.
   This avoids throwing Quota errors in UI event handlers. */
function addMessageToSessionMirror(role, content){
  const s = getSession();
  s.history.push({ role, content, ts: Date.now() });
  // enforce CHAT_LIMIT in-memory
  if(s.history.length > CHAT_LIMIT){
    s.history = s.history.slice(-CHAT_LIMIT);
  }
  // cap stored history to MAX_SESSION_HISTORY on persist
  const toPersist = { startedAt: s.startedAt, history: s.history.slice(-MAX_SESSION_HISTORY) };
  // update UI counts asap
  setSession(toPersist); // safe: this will trim silently if needed
  updateSessionUI();
}

/* UI render functions */
function appendMessageToUI(role, content, ts, opts){
  opts = opts || {};
  const wrap = document.createElement('div'); wrap.className = 'msg msg-enter';
  const av = document.createElement('div'); av.className = 'avatar ' + (role==='user' ? 'user' : 'g'); av.textContent = role==='user' ? 'U' : 'G';
  const cont = document.createElement('div'); cont.className = 'bubble' + (opts.ghost ? ' ghost' : '');
  cont.innerHTML = mdInline(content);
  const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = ts ? new Date(ts).toLocaleString() : '';
  const holder = document.createElement('div'); holder.className = 'msg-wrap'; holder.appendChild(cont); holder.appendChild(meta);
  wrap.appendChild(av); wrap.appendChild(holder);
  chatArea.appendChild(wrap); chatArea.scrollTop = chatArea.scrollHeight;
  return { wrap, bubble: cont, meta, av };
}

function appendAssistantTyping(){
  const { wrap, bubble, meta } = appendMessageToUI('assistant', '<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>', Date.now(), { ghost:true });
  return { wrap, bubble, meta };
}

/* streamType: slower and safe (no unescaped injection) */
function streamType(element, text, speed){
  return new Promise(resolve=>{
    const plain = String(text||'');
    let i = 0;
    element.innerHTML = '';
    const chunkSize = 1; // slow, readable
    const step = ()=>{
      if(i >= plain.length){ resolve(); return; }
      const sub = plain.slice(i, i+chunkSize);
      element.innerHTML += escapeHtml(sub);
      i += chunkSize;
      chatArea.scrollTop = chatArea.scrollHeight;
      setTimeout(step, speed);
    };
    step();
  });
}

/* ===========================
   Memory & Local generator code (kept mostly as you had)
   plus smarter web merging
   =========================== */

/* helper tokenizers */
function tokenize(s){
  if(!s) return [];
  return String(s).toLowerCase().replace(/[^a-z0-9\s]/g,' ').split(/\s+/).map(x=>x.trim()).filter(Boolean).filter(w=>w.length>2);
}
function tfMap(tokens){ const m={}; for(const t of tokens) m[t]=(m[t]||0)+1; return m; }
function ngrams(tokens){ const out=[]; for(let n=1;n<=3;n++) for(let i=0;i+n<=tokens.length;i++) out.push(tokens.slice(i,i+n).join(' ')); return out; }
function analyzeText(text){ const t=tokenize(text); const ng=ngrams(t); return { tokens: t.concat(ng), tf: tfMap(t.concat(ng)) }; }
function chunkText(text, size){ const out=[]; text=(text||'').trim(); if(!text) return out; for(let i=0;i<text.length;i+=size) out.push(text.slice(i,i+size)); return out; }

/* simple memory store (use existing LS_STATE pattern) */
let STATE = (function(){
  try{ const raw = localStorage.getItem(LS_STATE); if(raw) return JSON.parse(raw); }catch(e){}
  return {
    key: 'local-key-xyz',
    learn: true,
    models: [
      { id: 'gomega-1.o', label: 'gomega-1.o (legacy)' },
      { id: 'gomega-2.o', label: 'gomega-2.o (concise)' },
      { id: 'gomega-3.o-mini', label: 'gomega-3.o-mini (mini)' },
      { id: 'gomega-4.o', label: 'gomega-4.o (smart)' },
      { id: 'gomega-5.o', label: 'gomega-5.o (insane)' }
    ],
    systemKnowledge: 'Gomega.watch local system knowledge',
    memory: { maxEntries: 5000, chunkSize: 480 },
    profiles: { 'assistant.concise': { desc:'Short & exact' }, 'assistant.balanced': { desc:'Balanced' }, 'assistant.dev': { desc:'Developer' } },
    memories: []
  };
})();

function persistState(){ try{ localStorage.setItem(LS_STATE, JSON.stringify(STATE)); }catch(e){ /* ignore state persist failure */ } }

/* store memory with chunking like before */
function storeMemory(role, text){
  if(!STATE.learn) return;
  const txt = String(text||'').trim();
  if(!txt) return;
  if(txt.length < 30 && /^(hi|hello|hey)$/i.test(txt)) return;
  const pieces = chunkText(txt, STATE.memory.chunkSize || 480);
  const ts = Date.now();
  for(const p of pieces){ const a = analyzeText(p); STATE.memories.push({ role, text: p, ts, tokens: a.tokens, tf: a.tf }); }
  if(STATE.memories.length > (STATE.memory.maxEntries||3000)) STATE.memories = STATE.memories.slice(-STATE.memory.maxEntries);
  persistState();
}

/* retrieval (small) */
function idfMap(docs){
  const df={}; for(const d of docs){ const ks = Object.keys(d); const seen = new Set(ks); for(const k of seen) df[k] = (df[k]||0) + 1; }
  const idf = {}; const N = docs.length || 1; for(const k in df) idf[k] = Math.log(1 + N / (df[k]||1)); return idf;
}
function dot(a,b,idf){ let s=0; for(const k in a){ if(!b[k]) continue; const ai=a[k], bi=b[k]; const w = idf && idf[k] ? idf[k] : 1; s += ai * bi * w * w; } return s; }
function norm(v,idf){ let s=0; for(const k in v){ const w = idf && idf[k] ? idf[k] : 1; s += (v[k]*w)*(v[k]*w); } return Math.sqrt(s||1); }
function retrieveRelevant(query, topN=6){
  if(!STATE.memories.length) return [];
  const qTokens = tokenize(query);
  const qTF = tfMap(ngrams(qTokens).concat(qTokens));
  const docsTF = STATE.memories.map(m=>m.tf||{});
  const idf = idfMap(docsTF.concat([qTF]));
  const qNorm = norm(qTF, idf);
  const now = Date.now();
  const scored = STATE.memories.map(m=>{
    let sc = dot(qTF, m.tf||{}, idf) / (qNorm * norm(m.tf||{}, idf) || 1);
    const ageHours = (now - (m.ts||now)) / (1000*60*60);
    const recencyBoost = Math.max(0, 1 - Math.min(1, ageHours / (24*7)));
    sc = sc * (0.6 + 0.8 * recencyBoost);
    if(m.role === 'assistant') sc *= 1.05;
    return { m, score: sc||0 };
  });
  scored.sort((a,b)=>b.score-a.score);
  return scored.filter(s=>s.score>0.02).slice(0,topN);
}

/* Safe math / safe-run kept as before (no changes) */
function isSafeMathExpr(expr){ if(/[A-Za-z]/.test(expr)) return false; return /^[\d\s+\-*/^().%,]+$/.test(expr); }
function mathSteps(expr){
  const steps = []; const sanitized = expr.replace(/,/g,'').replace(/\s+/g,'');
  if(!isSafeMathExpr(sanitized)) return { error: 'Expression contains unsafe characters.' };
  const tokens = []; let i=0;
  while(i<sanitized.length){
    const ch = sanitized[i];
    if(/\d|\./.test(ch)){ let num=ch; i++; while(i<sanitized.length && /[\d.]/.test(sanitized[i])) num += sanitized[i++]; tokens.push({type:'num', value:num}); continue; }
    if(/[+\-*/^()%]/.test(ch)){ tokens.push({type:'op', value:ch}); i++; continue; }
    return { error:'Unexpected char' };
  }
  const prec = {'+':1,'-':1,'*':2,'/':2,'%':2,'^':3}; const right = {'^':true};
  const outQ = []; const ops = [];
  for(const t of tokens){
    if(t.type==='num') outQ.push(t);
    else {
      if(t.value==='('){ ops.push(t); continue; }
      if(t.value===')'){ let found=false; while(ops.length){ const top = ops.pop(); if(top.value==='('){ found=true; break; } outQ.push(top); } if(!found) return { error:'Mismatched parentheses' }; continue; }
      while(ops.length){
        const top = ops[ops.length-1];
        if(top.value==='(') break;
        const p1 = prec[t.value] || 0, p2 = prec[top.value] || 0;
        if((!right[t.value] && p1 <= p2) || (right[t.value] && p1 < p2)) outQ.push(ops.pop()); else break;
      }
      ops.push(t);
    }
  }
  while(ops.length){ const top = ops.pop(); if(top.value==='('||top.value===')') return { error:'Mismatched parentheses' }; outQ.push(top); }
  const stack = [];
  for(const t of outQ){
    if(t.type==='num') stack.push(parseFloat(t.value));
    else { const b = stack.pop(), a = stack.pop(); if(typeof a === 'undefined' || typeof b === 'undefined') return { error:'Invalid expression' }; let res;
      switch(t.value){ case '+': res = a + b; steps.push(`${a} + ${b} = ${res}`); break; case '-': res = a - b; steps.push(`${a} - ${b} = ${res}`); break;
        case '*': res = a * b; steps.push(`${a} × ${b} = ${res}`); break; case '/': if(b===0) return { error:'Division by zero' }; res = a / b; steps.push(`${a} ÷ ${b} = ${res}`); break;
        case '%': res = a % b; steps.push(`${a} % ${b} = ${res}`); break; case '^': res = Math.pow(a,b); steps.push(`${a} ^ ${b} = ${res}`); break;
        default: return { error:'Unknown operator' } } stack.push(res);
    }
  }
  if(stack.length !== 1) return { error:'Invalid expression after evaluation' };
  return { result: stack[0], steps };
}
function safeJsRun(code){
  const forbid = /\b(document|window|fetch|XMLHttpRequest|localStorage|eval|Function|require|import|process|globalThis|postMessage|self|Worker)\b/;
  if(forbid.test(code)) return { error:'Forbidden globals' };
  const allowed = /^[\s0-9\[\]\{\}\:\,\"\'.\-+*\/\%\^\(\)A-Za-z_]+$/;
  if(!allowed.test(code)) return { error:'Contains disallowed chars' };
  if(/\b(Math|JSON)\b/.test(code)===false && /[A-Za-z_]{2,}/.test(code)) return { error:'Only Math/JSON allowed' };
  try{ const fn = new Function('"use strict"; return (' + code + ')'); const v = fn(); return { result: v }; }catch(err){ return { error: 'Runtime: ' + (err && err.message) }; }
}

/* ===========================
   Local generator: improved heuristics
   - parseModelStrength unchanged
   - localGenerate improved with more robust fallbacks and clearer replies
   =========================== */
function parseModelStrength(modelId){
  if(!modelId) return 4;
  const m = (''+modelId).toLowerCase();
  const found = m.match(/gomega-(\d+)/);
  const n = found ? Number(found[1]) : (m.includes('4')?4:5);
  return n;
}

function inferFollowUpIntent(lastAssistantText, userReply){
  const lower = (lastAssistantText||'').toLowerCase();
  const affirm = /^(yes|sure|please|do it|ok|yeah|yep|please do|go ahead)$/i;
  if(affirm.test(userReply.trim())) {
    if(lower.includes('would you like me to search') || lower.includes('search for specifics')) return 'search';
    if(lower.includes('want me to expand') || lower.includes('which step to expand')) return 'expand';
    if(lower.includes('want me to produce')) return 'patch';
  }
  return null;
}

/* localGenerate - returns a helpful local answer */
function localGenerate(messages, temperature=0.7, modelId='gomega-4.o', thinkMode=false, options={}){
  let lastUser = '';
  let lastAssistant = '';
  for(let i=messages.length-1;i>=0;i--){ if(messages[i].role==='user' && !lastUser) lastUser = messages[i].content||''; if(messages[i].role==='assistant' && !lastAssistant) lastAssistant = messages[i].content||''; }
  const q = String(lastUser||'').trim();
  const lq = q.toLowerCase();
  const strength = parseModelStrength(modelId);
  const powerful = strength >= 4;

  if(/\bwhat model (are you|is this)\b|\bwhich model (are you|is this)\b/i.test(lq)) return 'I am GPT-5 Thinking mini, running as Gomega AI (local).';

  if(/^(hi|hello|hey|hiya|sup)[\!\.\s]*$/i.test(q)){
    if(powerful){
      const variants = ["Hi — I'm Gomega AI. I can help with code, games, gomega.watch pages, and quick calculations. What would you like to do?", "Hello! Gomega AI here — I know about gomega.watch/schoolgames, /music, and /scripts. Ask me anything."];
      return variants[Math.floor(Math.random()*variants.length)];
    } else {
      return "Hi — how can I help?";
    }
  }

  if(q.length < 40){
    const follow = inferFollowUpIntent(lastAssistant, q);
    if(follow === 'search'){
      return `Okay — I will look for specifics. (Expert mode can fetch web info.)`;
    }
    if(follow === 'expand'){
      return `Which step would you like me to expand? 1) Clarify goal 2) Break down tasks 3) Example 4) Test & iterate`;
    }
  }

  if(lq.startsWith('calc:') || /^calc\s*:/.test(lq) || lq.startsWith('calculate:')){
    const expr = q.split(':').slice(1).join(':').trim();
    if(!expr) return 'Provide expression after calc:';
    const res = mathSteps(expr);
    if(res.error) return `Calculator error: ${res.error}`;
    return `Calculation (step-by-step):\n\n${(res.steps||[]).join('\n')}\n\nResult: ${res.result}`;
  }

  if(/\bgomega\.watch\b|\bschoolgames\b|\bmusic\b|\bscripts\b|\broblox\b/i.test(lq)){
    const items = [];
    if(/schoolgames/i.test(lq)) items.push('School Games: gomega.watch/schoolgames — curated school-friendly titles and quickplay links.');
    if(/music/i.test(lq)) items.push('Music: gomega.watch/music — lessons, playlists, and beginner-friendly resources.');
    if(/script|roblox/i.test(lq)) items.push('Scripts: gomega.watch/scripts — snippets, Roblox examples, and small utilities.');
    if(items.length===0) items.push('Gomega.watch contains School Games, Music, Scripts, and more. Try the subpages for details.');
    if(powerful){
      return items.join('\n') + '\n\nI can search specific pages for titles, code examples, or resources — say "Yes please" to let me look (Expert mode will try web lookups).';
    } else {
      return items.join('\n') + '\n\nWould you like a short list or an example?';
    }
  }

  const codeBlock = q.match(/```([\w-]*)\n([\s\S]*?)```/);
  if(codeBlock){
    const lang = codeBlock[1] || 'unknown';
    const code = codeBlock[2];
    const hints = [];
    if(/console\.log\(/.test(code)) hints.push('If this is asynchronous, check that promises are awaited.');
    if(/==[^=]/.test(code)) hints.push('Use === instead of == to avoid coercion in JS.');
    if(/document\.getElementById|querySelector/.test(code)) hints.push('Ensure DOM access runs after DOMContentLoaded.');
    if(!hints.length) hints.push('Paste the exact error message and I will propose a minimal fix.');
    if(powerful){
      return `Detected ${lang} code. Quick diagnostic:\n- ${hints.join('\n- ')}\n\nIf you want, I will propose a small patch and explain the fix line-by-line.`;
    } else {
      return `Detected ${lang} code. Try checking these: ${hints.join('; ')}`;
    }
  }

  const hits = retrieveRelevant(q, 8);
  if(hits.length && hits[0].score > (powerful ? 0.06 : 0.12)){
    if(powerful){
      const lines = hits.map(h=>`• ${h.m.role}: ${h.m.text.slice(0,220).replace(/\n/g,' ')} (${new Date(h.m.ts).toLocaleDateString()})`);
      return `I found related notes and combined them into an answer:\n\n${lines.join('\n')}\n\nWould you like this expanded into steps or an example?`;
    } else {
      return `Related memory: ${hits[0].m.text.split('\n')[0].slice(0,300)}`;
    }
  }

  const tokens = tokenize(q);
  if(q.length < 80 && tokens.length >= 1){
    if(tokens.includes('game') || tokens.includes('games')) {
      return powerful ? 'Do you want recommended school-friendly games, or details about a particular title on gomega.watch/schoolgames?' : 'Do you want a short list of games or instructions?';
    }
    if(tokens.includes('music') || tokens.includes('song')) {
      return powerful ? 'Would you like lessons, sheet links, or playlists from gomega.watch/music?' : 'Do you want song suggestions or lessons?';
    }
    if(tokens.includes('roblox') || tokens.includes('script')) {
      return powerful ? 'I can show example Roblox scripts and explain them step-by-step — would you like a beginner example?' : 'Do you want a simple Roblox script example?';
    }
    if(tokens.includes('help') || tokens.includes('fix') || tokens.includes('error')) {
      return powerful ? 'Paste the code or error — I will analyze and propose a minimal patch with reasoning.' : 'Paste code or error and I will suggest fixes.';
    }
    if(powerful){
      const guess = tokens.slice(0,7).join(' ');
      return `I think you mean: "${guess}...". Do you want a short summary, examples, or step-by-step instructions?`;
    }
    return `Can you add a little more detail so I can answer precisely?`;
  }

  if(powerful){
    return `Plan:\n1) Clarify goal and constraints.\n2) Break problem into tasks.\n3) Provide an example or quick snippet.\n4) Test and iterate.\n\nTell me which step to expand, or paste details and I'll produce code/steps.`;
  } else {
    return `Start by clarifying the goal, then ask for an example or paste code to debug.`;
  }
}

/* ===========================
   Web search helper + extractive summarizer
   - webSearch uses DDG instant answer (like before)
   - extractTopSentences picks best sentences by token overlap with query
   =========================== */
async function webSearch(query, maxTopics=4){
  try{
    if(!query) return '';
    // skip extremely short greetings
    if(/^(hi|hello|hey|hiya|sup)[\!\.\s]*$/.test(query.trim().toLowerCase())) return '';
    const ddg = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_html=1&skip_disambig=1`;
    const r = await fetch(ddg, { method:'GET' });
    if(!r.ok) return '';
    const j = await r.json();
    const parts = [];
    if(j.AbstractText) parts.push(j.AbstractText);
    if(Array.isArray(j.RelatedTopics)){
      for(const t of j.RelatedTopics.slice(0,maxTopics)){
        if(typeof t === 'string' && t) parts.push(t);
        else if(t && t.Text) parts.push(t.Text);
        else if(t && Array.isArray(t.Topics)){
          for(const sub of (t.Topics||[]).slice(0,1)) if(sub.Text) parts.push(sub.Text);
        }
      }
    }
    return parts.join('\n\n').trim();
  }catch(e){ return ''; }
}

function extractTopSentences(text, query, limit=3){
  if(!text) return '';
  const sentences = text.split(/(?<=[.?!])\s+/);
  const qtokens = tokenize(query);
  const scores = sentences.map(s=>{
    const st = tokenize(s);
    let score = 0;
    for(const q of qtokens) if(st.includes(q)) score += 1;
    score += Math.min(1, st.length/30); // slight bias for longer informative sentence
    return { s, score };
  });
  scores.sort((a,b)=>b.score-a.score);
  const picked = scores.filter(x=>x.score>0).slice(0,limit).map(x=>x.s);
  if(picked.length) return picked.join(' ');
  // fallback: first N sentences
  return sentences.slice(0,limit).join(' ');
}

function shortenText(text, opts){
  opts = opts || {};
  const maxSentences = opts.maxSentences || 3;
  const maxChars = opts.maxChars || 600;
  if(!text) return '';
  const sentences = text.split(/(?<=[.?!])\s+/);
  const picked = sentences.slice(0, maxSentences).join(' ');
  if(picked.length <= maxChars) return picked.trim();
  const trimmed = picked.slice(0, maxChars);
  return trimmed.replace(/\s+\S*$/, '') + '…';
}

/* ===========================
   Form submit flow: robust
   - uses safe setSession (won't throw)
   - uses webSearch+extractTopSentences to improve replies
   - disables input while assistant types
   - slower typing (60ms for powerful)
   =========================== */

form.addEventListener('submit', async (ev)=>{
  ev.preventDefault();
  const content = (promptEl.value||'').trim();
  if(!content) return;

  // basic filter
  if(/fuck|shit|bitch|asshole/i.test(content)){
    appendMessageToUI('assistant', 'Message blocked by chat filter: inappropriate language.', Date.now());
    promptEl.value=''; return;
  }

  // chat limit check
  const s = getSession();
  if((s.history||[]).length >= CHAT_LIMIT){
    appendMessageToUI('assistant', "Gomega AI chat limit reached — start a new chat or reset.", Date.now());
    promptEl.value=''; return;
  }

  // commands
  if(content === '/reset'){ 
    const newSess = { startedAt: Date.now(), history: [] };
    setSession(newSess); IN_MEMORY_SESSION = newSess;
    renderSessionUI(); promptEl.value=''; updateSessionUI(); return; 
  }
  if(content === '/memories'){ openMemViewer(); promptEl.value=''; return; }
  if(content.toLowerCase().startsWith('remember:')){
    const note = content.slice(9).trim();
    if(note){
      // store as memory via local chat endpoint to reuse existing storeMemory logic
      try{
        await fetch('/api/chat', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ messages:[{role:'user', content:`remember: ${note}`}], modelId: modelSelect.value })});
        alert('Saved to memories.');
      }catch(e){ alert('Failed to save memory'); }
    } else alert('Provide text after remember:');
    promptEl.value=''; return;
  }

  // append user message to UI and in-memory session
  addMessageToSessionMirror('user', content);
  appendMessageToUI('user', content, Date.now());
  promptEl.value='';

  // show ghost thinking if enabled
  let ghost = null;
  if(thinkToggle.checked){
    try{
      const memResp = await fetch('/api/memories'); const memJson = memResp.ok?await memResp.json():{memories:[]};
      const matches = (memJson.memories||[]).filter(m=> m.text.toLowerCase().includes(content.slice(0,30).toLowerCase())).slice(0,3).map(m=>m.text);
      const summ = matches.length ? `Thinking about: ${matches.slice(0,2).join(' | ')}` : `Thinking about: ${content.slice(0,120)}`;
      ghost = appendMessageToUI('assistant', summ, Date.now(), { ghost:true });
    }catch(e){
      ghost = appendMessageToUI('assistant', 'Thinking...', Date.now(), { ghost:true });
    }
  }

  // show typing placeholder
  const typing = appendAssistantTyping();

  // decide forced web behavior
  const forcedWebModels = new Set(['gomega-5.o','gomega-4.o','gomega-4.o-mini']);
  const selectedModel = (modelSelect.value||'gomega-4.o').toLowerCase();
  const shouldForceWeb = forcedWebModels.has(selectedModel);
  const skipWebForShortGreetings = /^(hi|hello|hey|hiya|sup)[\!\.\s]*$/i.test(content);

  // begin local generation in parallel
  let baseReply = '';
  try{
    const payload = { messages: getSession().history.slice(-180), modelId: modelSelect.value || 'gomega-4.o', thinkMode: thinkToggle.checked };
    const resp = await fetch('/api/chat', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
    if(resp.ok){ const j = await resp.json(); baseReply = j.text || String(j); } else baseReply = `Error: generator ${resp.status}`;
  }catch(err){ baseReply = `Local generation failed: ${err && err.message}`; }

  // run web search only if allowed (forced model or expertToggle) and not a short greeting
  let expertData = '';
  try{
    if(!skipWebForShortGreetings && (shouldForceWeb || expertToggle.checked)){
      let q = content;
      if(/\bgomega\.watch\b|\bschoolgames\b|\bmusic\b|\bscripts\b/.test(content.toLowerCase())) q = 'site:gomega.watch ' + content;
      const web = await webSearch(q, 4);
      expertData = web || '';
    }
  }catch(e){
    expertData = '';
  }

  // merge web + local with extractive summarization for web
  let finalAnswer = '';
  function isLocalAnswerWeak(text){
    if(!text) return true;
    const t = text.toLowerCase();
    if(t.length < 80) return true;
    const weakPhrases = ['i can search','i can look','would you like','plan:','clarify goal','start by clarifying'];
    for(const p of weakPhrases) if(t.includes(p)) return true;
    return false;
  }

  if(expertData && expertData.length > 40){
    const webBest = extractTopSentences(expertData, content, 3);
    const webShort = shortenText(webBest, { maxSentences: 3, maxChars: 700 });
    const localShort = shortenText(baseReply, { maxSentences: 5, maxChars: 900 });

    if(isLocalAnswerWeak(baseReply)){
      finalAnswer = webShort;
    } else {
      // if web offers strong focused info, prefer it then append concise local reasoning
      const webWords = (webShort||'').split(/\s+/).length;
      const localWords = (localShort||'').split(/\s+/).length;
      if(webWords >= localWords){
        finalAnswer = webShort + (localShort ? '\n\n' + localShort : '');
      } else {
        finalAnswer = localShort + (webShort ? '\n\nReference: ' + webShort : '');
      }
    }
  } else {
    finalAnswer = shortenText(baseReply, { maxSentences: 6, maxChars: 1200 }) || 'Sorry, I could not generate an answer.';
  }

  // fade ghost
  if(ghost && ghost.bubble){
    try{ ghost.bubble.innerHTML = mdInline('Now forming a solid answer...'); }catch(e){} 
    await new Promise(r=>setTimeout(r, 300 + Math.random()*350));
    ghost.wrap.style.opacity = '0.5';
  }

  // disable input while typing
  promptEl.disabled = true;
  sendBtn.disabled = true;

  // typing speed: slower (60 ms per char for powerful)
  const strength = parseModelStrength(selectedModel);
  const typingSpeed = strength >= 4 ? 60 : 80;

  await streamType(typing.bubble, finalAnswer, typingSpeed);
  typing.meta.textContent = `model: ${modelSelect.value||'gomega-4.o'}`;

  // store assistant memory and session safely
  storeMemory('assistant', finalAnswer);
  addMessageToSessionMirror('assistant', finalAnswer);

  // re-enable input
  promptEl.disabled = false;
  sendBtn.disabled = false;
  promptEl.focus();
  updateSessionUI();
});

/* ===========================
   UI / session helpers
   =========================== */
function updateSessionUI(){
  const s = getSession();
  $('#sessStart') && ($('#sessStart').textContent = new Date(s.startedAt).toLocaleString());
  $('#histCount') && ($('#histCount').textContent = (s.history||[]).length);
  chatLimitDisplay.textContent = Math.max(0, CHAT_LIMIT - (s.history||[]).length);
}

function renderSessionUI(){
  chatArea.innerHTML = '';
  const s = getSession();
  for(const m of (s.history||[])) appendMessageToUI(m.role, m.content, m.ts);
}
renderSessionUI();

/* ===========================
   Config UI wiring (models, suggestions, mem viewer, tools)
   Many parts kept similar to your previous file.
   =========================== */
async function loadConfigUI(){
  try{
    const r = await fetch('/api/config'); const cfg = r.ok?await r.json():{};
    const models = cfg.models || [{id:'gomega-4.o',label:'gomega-4.o'}];
    modelSelect.innerHTML = '';
    const pref = [{id:'gomega-1.o',label:'gomega-1.o (legacy)'},{id:'gomega-2.o',label:'gomega-2.o (concise)'},{id:'gomega-3.o-mini',label:'gomega-3.o-mini (mini)'}];
    for(const p of pref) if(!models.find(m=>m.id===p.id)) models.unshift(p);
    if(!models.find(m=>m.id==='gomega-4.o-mini')) models.push({ id:'gomega-4.o-mini', label: 'gomega-4.o-mini (smart mini)' });
    if(!models.find(m=>m.id==='gomega-4.o')) models.push({ id:'gomega-4.o', label: 'gomega-4.o (smart)' });
    if(!models.find(m=>m.id==='gomega-5.o')) models.push({ id:'gomega-5.o', label: 'gomega-5.o (insane)' });

    const seen = new Set();
    for(const m of models){ if(seen.has(m.id)) continue; const o = document.createElement('option'); o.value = m.id; o.textContent = m.label || m.id; modelSelect.appendChild(o); seen.add(m.id); }
    modelBadge.textContent = 'Model: ' + modelSelect.value;
    profileSelect.innerHTML = '';
    const profs = cfg.profiles || {};
    for(const k in profs){ const o = document.createElement('option'); o.value=k; o.textContent = `${k} — ${profs[k].desc||''}`; profileSelect.appendChild(o); }
    sysInfo.textContent = (cfg.systemKnowledge || '').slice(0,2000);
    updateSessionUI();
  }catch(e){ console.warn('cfg err', e); }
}
loadConfigUI();

modelSelect.addEventListener('change', ()=>{ modelBadge.textContent = 'Model: ' + modelSelect.value; });

document.querySelectorAll('.suggestion').forEach(el=>{
  el.addEventListener('click', ()=>{ const q = el.getAttribute('data-q'); promptEl.value = q; promptEl.focus(); });
});

function openMemViewer(){ modal.style.display = 'flex'; renderMemList(); }
viewMem.addEventListener('click', openMemViewer);
openMemViewerBtn.addEventListener('click', openMemViewer);
closeMem.addEventListener('click', ()=> modal.style.display = 'none');

async function renderMemList(query=''){
  memList.innerHTML = '';
  try{
    const r = await fetch('/api/memories'); if(!r.ok) throw new Error('mem failed'); const j = await r.json();
    const arr = (j.memories||[]).slice().reverse();
    for(const m of arr){ if(query && !m.text.toLowerCase().includes(query.toLowerCase())) continue; const d = document.createElement('div'); d.className='card'; d.style.padding='8px'; d.style.marginBottom='8px'; d.innerHTML = `<div style="font-size:12px;color:var(--muted)">${m.role.toUpperCase()} • ${new Date(m.ts).toLocaleString()}</div><div style="margin-top:6px">${mdInline(m.text)}</div>`; memList.appendChild(d); }
  }catch(e){ memList.textContent = 'Failed to load memories.'; }
}
memSearch.addEventListener('input', ()=> renderMemList(memSearch.value));

$('#exportMem').addEventListener('click', async ()=>{
  try{ const r = await fetch('/api/memories'); if(!r.ok) throw new Error('export failed'); const j = await r.json(); const blob = new Blob([JSON.stringify(j.memories||[], null, 2)], { type:'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `gomega-memories-${new Date().toISOString().slice(0,10)}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }catch(e){ alert('Export failed'); }
});
$('#importFile').addEventListener('change', async (ev)=>{
  const f = ev.target.files && ev.target.files[0]; if(!f) return;
  try{ const txt = await f.text(); const arr = JSON.parse(txt); if(!Array.isArray(arr)) throw new Error('expected array'); const st = (await fetch('/api/memories').then(r=>r.ok?r.json():{memories:[]}).catch(()=>({memories:[]}))).memories || []; const merged = (st.concat(arr)).slice(-2000); const raw = JSON.parse(localStorage.getItem(LS_STATE)||'{}'); raw.memories = merged.map(m=>({ role:m.role||'assistant', text:m.text||m, ts:m.ts||Date.now(), tokens:[], tf:{} })); localStorage.setItem(LS_STATE, JSON.stringify(raw)); alert('Imported memories. Reload page to refresh.'); }catch(e){ alert('Import failed: '+(e.message||e)); } ev.target.value='';
});
clearMem.addEventListener('click', async ()=>{ if(!confirm('Clear all memories permanently?')) return; try{ const r = await fetch('/api/clear-memories', { method:'POST' }); if(!r.ok) throw new Error('clear failed'); alert('Memories cleared.'); }catch(e){ alert('Failed to clear memories'); } });

openCalc.addEventListener('click', ()=> { $('#calcModal').style.display='flex'; calcInput && calcInput.focus(); });
closeCalc && closeCalc.addEventListener('click', ()=> $('#calcModal').style.display='none');
calcRun && calcRun.addEventListener('click', async ()=>{ const expr = calcInput.value.trim(); if(!expr){ calcOut.textContent='Enter an expression.'; return; } try{ const r = await fetch('/api/tools/math', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ expr })}); const j = await r.json(); if(j.error) calcOut.textContent = 'Error: ' + j.error; else calcOut.textContent = 'Steps:\n' + (j.steps||[]).join('\n') + '\n\nResult: ' + j.result; }catch(e){ calcOut.textContent = 'Failed to run calculator.'; } });

$('#openSafeRun') && $('#openSafeRun').addEventListener('click', ()=>{ $('#safeRunModal').style.display='flex'; safeCode && safeCode.focus(); });
$('#closeSafeRun') && $('#closeSafeRun').addEventListener('click', ()=>{ $('#safeRunModal').style.display='none'; });
safeRun && safeRun.addEventListener('click', async ()=>{ const code = safeCode.value.trim(); if(!code){ safeOut.textContent='Enter code or expression.'; return; } try{ const r = await fetch('/api/tools/safe-run', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ code })}); const j = await r.json(); if(j.error) safeOut.textContent = 'Error: ' + j.error; else safeOut.textContent = 'Result:\n' + JSON.stringify(j.result, null, 2); }catch(e){ safeOut.textContent = 'Failed to run code.'; } });

$('#openRegex') && $('#openRegex').addEventListener('click', ()=>{ const pattern = prompt('Enter regex pattern (no flags):'); if(!pattern) return; const text = prompt('Enter text to test against:') || ''; try{ const re = new RegExp(pattern); const match = re.exec(text); alert(match ? 'Match found: ' + JSON.stringify(match) : 'No match.'); }catch(e){ alert('Invalid regex: ' + e.message); } });

(function init(){ const sess = getSession(); $('#sessStart') && ($('#sessStart').textContent = new Date(sess.startedAt).toLocaleString()); $('#histCount') && ($('#histCount').textContent = (sess.history||[]).length); chatLimitDisplay.textContent = Math.max(0, CHAT_LIMIT - (sess.history||[]).length); })();

</script>
</body>
</html>
