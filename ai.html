<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gomega AI — ai.html (local)</title>

<!-- -------------------------
  IMPORTANT: This file is an enhanced version of your ai.html.
  I kept your original UI and behavior but added many features:
  - enhanced memory retrieval (tf-idf + ngrams + recency)
  - model profiles (math/coding/writing/creative/tutor)
  - safe math engine (digit-by-digit steps)
  - code helper heuristics (detect code blocks, suggest fixes)
  - small local tools (calculator, regex tester, sandbox runner)
  - improved streaming/think mode & per-model defaults
--------------------------- -->

<!-- In-page /api override (must be first) -->
<script>
(function(){
  const origFetch = window.fetch.bind(window);

  // ----------- persistent local state --------------
  const PKEY = 'gomega_local_state_v4';
  const SESSION_KEY = 'gomega_session_v4';

  const DEFAULT = {
    key: "local-key-123456",
    learn: true,
    models: [
      { id: 'gomega-2.o', label: 'gomega-2.o (concise)', profile: 'assistant.concise' },
      { id: 'gomega-3.o', label: 'gomega-3.o (conservative)', profile: 'assistant.safe' },
      { id: 'gomega-4.o', label: 'gomega-4.o (balanced)', profile: 'assistant.balanced' },
      { id: 'gomega-5.o', label: 'gomega-5.o (beta)', profile: 'assistant.beta' },
      { id: 'gomega-6.o', label: 'gomega-6.o (creative)', profile: 'assistant.creative' },
      { id: 'gomega-7.o', label: 'gomega-7.o (developer)', profile: 'assistant.dev' }
    ],
    // system knowledge that the assistant can reference
    systemKnowledge: `
You are Gomega AI — a local assistant running inside the user's browser.
Name: Gomega AI
Identity: GPT-5 Thinking mini (for direct "what model are you" questions).
Purpose: Help the user with coding, ideas, local testing, and remembering short facts locally.
Memory policy: Store meaningful user/assistant turns for retrieval. Do not store tiny greetings.
Limits: Chat session resets every 2 hours, but long-term memories persist unless the user clears them.
Knowledge: Use local heuristics and stored memories; do not call external servers.
    `.trim(),
    // memory tuning
    memory: { maxEntries: 3000, chunkSize: 480 },
    // model persona mappings (specialties)
    profiles: {
      'assistant.concise': { desc: 'Short, precise answers', specialties: ['summary','facts'] },
      'assistant.safe': { desc: 'Conservative, cautious replies', specialties: ['advice','safety'] },
      'assistant.balanced': { desc: 'Balanced helpful replies', specialties: ['coding','writing'] },
      'assistant.beta': { desc: 'Beta creative & curious', specialties: ['brainstorm','research'] },
      'assistant.creative': { desc: 'Creative writing & ideas', specialties: ['stories','poetry'] },
      'assistant.dev': { desc: 'Developer-focused; code help & debugging', specialties: ['math','coding','debug'] }
    }
  };

  // load persistent state
  let LOCAL = Object.assign({}, DEFAULT);
  try {
    const raw = localStorage.getItem(PKEY);
    if(raw) {
      const parsed = JSON.parse(raw);
      // merge safely
      LOCAL = Object.assign({}, DEFAULT, parsed);
      LOCAL.models = LOCAL.models || DEFAULT.models;
      LOCAL.systemKnowledge = LOCAL.systemKnowledge || DEFAULT.systemKnowledge;
      LOCAL.profiles = Object.assign({}, DEFAULT.profiles, LOCAL.profiles || {});
      LOCAL.memory = Object.assign({}, DEFAULT.memory, LOCAL.memory || {});
    } else {
      LOCAL = Object.assign({}, DEFAULT);
    }
  } catch(e) { console.warn('load state err', e); }

  // session state (history) with start timestamp
  let SESSION = { startedAt: Date.now(), history: [] }; // history: [{role,content,ts}]
  try {
    const rawS = localStorage.getItem(SESSION_KEY);
    if(rawS) SESSION = JSON.parse(rawS);
  } catch(e){ console.warn('load session err', e); }

  function persist() {
    try { localStorage.setItem(PKEY, JSON.stringify(LOCAL)); }
    catch(e){ console.warn('persist err', e); }
  }
  function persistSession() {
    try { localStorage.setItem(SESSION_KEY, JSON.stringify(SESSION)); }
    catch(e){ console.warn('persist session err', e); }
  }

  // ----------- text utilities & stronger retrieval --------------
  // Small stemmer-like function (very lightweight)
  function stem(word){
    return word.replace(/(ing|ed|ly|s)$/,'');
  }

  // Larger stoplist; preserve short but informative words >=3 chars
  const STOP = new Set([
    'the','is','in','on','and','a','an','of','to','for','i','you','me','it','that','this','with','are','was',
    'be','have','has','do','did','not','but','my','your','we','they','he','she','as','at','by','from','or','if',
    'so','just','like','will','can','also','than','then','too'
  ]);

  function tokenize(s){
    if(!s) return [];
    // allow unicode word chars; split on non word
    return String(s).toLowerCase().replace(/[^\p{L}\p{N}\s]/gu,' ').split(/\s+/)
      .map(t=>t.trim()).filter(w=>w.length>2 && !STOP.has(w)).map(stem);
  }

  // ngram builder (1..3)
  function ngrams(tokens){
    const out = [];
    for(let n=1;n<=3;n++){
      for(let i=0;i+ n <= tokens.length;i++){
        out.push(tokens.slice(i,i+n).join(' '));
      }
    }
    return out;
  }

  // build TF map
  function tfMap(tokens){
    const m = Object.create(null);
    for(const t of tokens) m[t] = (m[t]||0)+1;
    return m;
  }

  function idfMap(docs){
    const df = Object.create(null);
    for(const d of docs){
      const seen = new Set(Object.keys(d));
      for(const k of seen) df[k] = (df[k]||0)+1;
    }
    const idf = Object.create(null);
    const N = docs.length || 1;
    for(const k in df) idf[k] = Math.log(1 + N/(df[k]||1));
    return idf;
  }

  function dot(a,b,idf){
    let s = 0;
    for(const k in a){
      if(!b[k]) continue;
      const ai = a[k], bi = b[k];
      const w = idf && idf[k] ? idf[k] : 1;
      s += ai * bi * w * w;
    }
    return s;
  }

  function norm(v,idf){
    let s = 0;
    for(const k in v){
      const w = idf && idf[k] ? idf[k] : 1;
      s += (v[k]*w)*(v[k]*w);
    }
    return Math.sqrt(s || 1);
  }

  // chunk long user/assistant messages into fixed sized chunks for better retrieval
  function chunkText(text, size){
    const out = [];
    text = (text||'').trim();
    if(!text) return out;
    for(let i=0;i<text.length;i+=size){
      out.push(text.slice(i, i+size));
    }
    return out;
  }

  // analyze text -> tokens, tf
  function analyzeText(text){
    const baseTokens = tokenize(text);
    // include ngrams to improve phrase retrieval
    const ng = ngrams(baseTokens);
    const tokens = baseTokens.concat(ng);
    const tf = tfMap(tokens);
    return { tokens, tf };
  }

  // robust memory store; store chunks and metadata
  LOCAL.memories = LOCAL.memories || []; // each: {role,text,ts,tokens,tf}
  function storeMemory(role,text){
    if(!LOCAL.learn) return;
    const txt = String(text || '').trim();
    if(!txt) return;
    // skip tiny greetings
    if(txt.length < 30 && /^(hi|hello|hey|how are you|what's up|sup)$/i.test(txt)) return;
    // chunk large text to avoid losing context in long messages
    const chunks = chunkText(txt, LOCAL.memory.chunkSize || 480);
    const timestamp = Date.now();
    for(const c of chunks){
      const a = analyzeText(c);
      LOCAL.memories.push({ role, text: c, ts: timestamp, tokens: a.tokens, tf: a.tf });
    }
    // keep only last N
    if(LOCAL.memories.length > (LOCAL.memory.maxEntries||3000)) LOCAL.memories = LOCAL.memories.slice(- (LOCAL.memory.maxEntries||3000) );
    persist();
  }

  // retrieval: TF-IDF + recency boost + role bias
  function retrieveRelevant(query, topN=6){
    if(!LOCAL.memories.length) return [];
    const qTokens = tokenize(query);
    const qTF = tfMap(ngrams(qTokens).concat(qTokens));
    // build docs tf list
    const docsTF = LOCAL.memories.map(m => m.tf || {});
    const idf = idfMap(docsTF.concat([qTF]));
    const qNorm = norm(qTF, idf);
    // score
    const now = Date.now();
    const scored = LOCAL.memories.map(m => {
      let sc = dot(qTF, m.tf || {}, idf) / (qNorm * norm(m.tf || {}, idf) || 1);
      // recency boost (memories within 7 days get a boost)
      const ageHours = (now - (m.ts||now)) / (1000*60*60);
      const recencyBoost = Math.max(0, 1 - Math.min(1, ageHours / (24*7))); // 1 at 0 hours -> 0 at 7 days
      sc = sc * (0.6 + 0.8 * recencyBoost);
      // role bias: favor assistant memories slightly for paraphrase reuse
      if(m.role === 'assistant') sc *= 1.05;
      return { m, score: sc || 0 };
    });
    scored.sort((a,b)=>b.score-a.score);
    return scored.filter(s=>s.score>0.02).slice(0,topN);
  }

  // paraphrase helper (keeps concise)
  function paraphraseShort(text){
    const t = text.length > 240 ? text.slice(0,240) + '...' : text;
    const templates = [
      `I remember: ${t}`,
      `From before: ${t}`,
      `${t} — want me to expand?`
    ];
    return templates[Math.floor(Math.random()*templates.length)];
  }

  // system knowledge fetch
  function systemInfo(){
    return LOCAL.systemKnowledge || DEFAULT.systemKnowledge;
  }

  // ----------------- small local tools (safe) -----------------
  // Strict math expression validator and evaluator (digit-by-digit explanation)
  // Allowed characters: digits, whitespace, + - * / ^ ( ) . %, BigInt support via 'n' suffix not allowed
  function isSafeMathExpr(expr){
    // reject letters to avoid variable injection
    if(/[A-Za-z]/.test(expr)) return false;
    // allow digits, operators, parentheses, decimal point, spaces
    return /^[\d\s+\-*/^().%,]+$/.test(expr);
  }

  // evaluate math expression safely by tokenizing and using big decimal where needed.
  // We'll implement a simple shunting-yard and evaluate with step-by-step log:
  function mathSteps(expr){
    const outSteps = [];
    const sanitized = expr.replace(/,/g,'').replace(/\s+/g,'');
    if(!isSafeMathExpr(sanitized)) return { error: 'Expression contains unsafe characters.' };

    // replace ^ with ** for power; but we'll handle ^ as power operator
    // tokenization (numbers and ops)
    const tokens = [];
    let i=0;
    while(i<sanitized.length){
      const ch = sanitized[i];
      if(/\d|\./.test(ch)){
        let num = ch; i++;
        while(i<sanitized.length && /[\d.]/.test(sanitized[i])){ num += sanitized[i++]; }
        tokens.push({type:'num', value: num});
        continue;
      }
      if(ch === '+'||ch === '-'||ch === '*'||ch==='/'||ch==='^'||ch==='('||ch===')'||ch==='%'){
        tokens.push({type:'op', value: ch}); i++; continue;
      }
      // unexpected
      return { error: 'Unexpected character in expression.' };
    }

    // shunting-yard to RPN
    const prec = { '+':1, '-':1, '*':2, '/':2, '%':2, '^':3 };
    const rightAssoc = { '^':true };
    const outQueue = [];
    const opStack = [];
    for(const t of tokens){
      if(t.type === 'num') outQueue.push(t);
      else if(t.type === 'op'){
        if(t.value === '(') { opStack.push(t); continue; }
        if(t.value === ')'){
          let found=false;
          while(opStack.length){
            const top = opStack.pop();
            if(top.value === '('){ found=true; break; }
            outQueue.push(top);
          }
          if(!found) return { error: 'Mismatched parentheses' };
          continue;
        }
        while(opStack.length){
          const top = opStack[opStack.length-1];
          if(top.value === '(') break;
          const p1 = prec[t.value] || 0, p2 = prec[top.value] || 0;
          if( ( !rightAssoc[t.value] && p1 <= p2 ) || ( rightAssoc[t.value] && p1 < p2 ) ){
            outQueue.push(opStack.pop());
          } else break;
        }
        opStack.push(t);
      }
    }
    while(opStack.length){
      const top = opStack.pop();
      if(top.value==='(' || top.value===')') return { error: 'Mismatched parentheses' };
      outQueue.push(top);
    }

    // evaluate RPN with step logs
    const stack = [];
    let stepId=0;
    for(const t of outQueue){
      if(t.type === 'num'){
        stack.push(parseFloat(t.value));
      } else {
        const b = stack.pop(), a = stack.pop();
        if(typeof a === 'undefined' || typeof b === 'undefined') return { error: 'Invalid expression' };
        let res;
        switch(t.value){
          case '+': res = a + b; outSteps.push(`${a} + ${b} = ${res}`); break;
          case '-': res = a - b; outSteps.push(`${a} - ${b} = ${res}`); break;
          case '*': res = a * b; outSteps.push(`${a} × ${b} = ${res}`); break;
          case '/': res = b === 0 ? (function(){throw new Error('Division by zero')})() : a / b; outSteps.push(`${a} ÷ ${b} = ${res}`); break;
          case '%': res = a % b; outSteps.push(`${a} % ${b} = ${res}`); break;
          case '^': res = Math.pow(a,b); outSteps.push(`${a} ^ ${b} = ${res}`); break;
          default: return { error: 'Unknown operator' };
        }
        stack.push(res);
      }
    }
    if(stack.length !== 1) return { error: 'Invalid expression after evaluation' };
    return { result: stack[0], steps: outSteps };
  }

  // safe JS sandbox runner: extremely restricted. Only allow arithmetic expressions and JSON.parse/JSON.stringify usage.
  // We'll not use eval directly. Instead, we parse the input and only evaluate if it matches allowed patterns.
  function safeJsRun(code){
    // disallow dangerous constructs
    const forbidden = /\b(document|window|fetch|XMLHttpRequest|localStorage|eval|Function|require|import|process|globalThis|postMessage|self|Worker)\b/;
    if(forbidden.test(code)) return { error: 'Code uses forbidden globals.' };
    // allow only digits, Math, JSON, basic JS operators, arrays/objects with numbers/strings
    // quick whitelist check (very conservative)
    const allowed = /^[\s0-9\[\]\{\}\:\,\"\'.\-+*\/\%\^\(\)A-Za-z_]+$/;
    if(!allowed.test(code)) return { error: 'Contains disallowed characters.' };
    // disallow letters sequences other than Math and JSON and simple identifiers like x,y
    if(/\b(Math|JSON)\b/.test(code) === false && /[A-Za-z_]{2,}/.test(code)) {
      // if there are longer identifiers not Math/JSON, reject
      return { error: 'Only Math and JSON usage allowed in safe runner.' };
    }
    // small attempt: replace Math.* with calls to Math safely by evaluating expression via Function but in a sandboxed scope
    try{
      // construct Function but with no access to outer scope; still risky but checks above reduce risk
      const fn = new Function('"use strict"; return (' + code + ')');
      const value = fn();
      return { result: value };
    }catch(err){
      return { error: 'Runtime error: ' + (err && err.message) };
    }
  }

  // ----------------- generator (improved) -----------------
  // required: answer "what model are you" EXACTLY with "GPT-5 Thinking mini"
  function localGenerate(messages, temperature=0.7, modelId='gomega-4.o', thinkMode=false, extra={}){
    // compose last user
    let lastUser = "";
    for(let i=messages.length-1;i>=0;i--) if(messages[i].role==='user'){ lastUser = messages[i].content||''; break; }
    const q = String(lastUser || '').trim();
    const lq = q.toLowerCase();

    // quick tool triggers
    if(lq.startsWith('calc:') || /^calc\s*:/.test(lq) || lq.startsWith('calculate:')) {
      const expr = q.split(':').slice(1).join(':').trim();
      if(!expr) return 'Provide expression after calc:';
      const res = mathSteps(expr);
      if(res.error) return `Calculator error: ${res.error}`;
      // show step-by-step and final
      const steps = (res.steps || []).join('\n');
      return `Calculation (step-by-step):\n\n${steps}\n\nResult: ${res.result}`;
    }

    // Model identity query
    if(/\bwhat model (are you|is this)\b|\bwhich model (are you|is this)\b/i.test(lq)){
      return `I am GPT-5 Thinking mini, running as Gomega AI (local).`;
    }
    if(/\bwhat model am i using\b|\bwhich model am i using\b/i.test(lq)){
      return modelId ? `You're using **${modelId}** right now.` : `You're using the local model chosen in the UI.`;
    }
    if(/\bwho are you\b|\bwhat are you\b/i.test(lq)){
      return `I am Gomega AI — a local assistant running in your browser. I keep local memories and follow the system knowledge. (Identity: GPT-5 Thinking mini)`;
    }
    if(/\bdate\b|\btoday\b/i.test(lq) && /\bwhat\b|\bwhich\b|^\b/.test(lq)){
      return `Today is ${new Date().toDateString()}.`;
    }
    if(/\btime\b/i.test(lq) && /\bwhat\b|current/i.test(lq)){
      return `Current time: ${new Date().toLocaleTimeString()}.`;
    }

    // greetings + social small talk
    if(/^(hi|hello|hey|hiya|sup)[\!\.\s]*$/i.test(q)){
      const msgs = ["Hey — I'm Gomega AI. How can I help?", "Hi! Gomega AI here. What would you like to do today?", "Hello — ready to help. Ask me something!"];
      return msgs[Math.floor(Math.random()*msgs.length)];
    }
    if(/\bhow (are|is) (you|your day)\b|\bhow's your day\b/i.test(lq)){
      return ["I'm ready and running locally — how's your day?", "Doing well — ready to help you with code, ideas, or memory."][Math.floor(Math.random()*2)];
    }

    // memory search shortcut
    if(lq.startsWith('search memory:')) {
      const term = q.slice(14).trim();
      if(!term) return 'Provide a term after "search memory:".';
      const hits = retrieveRelevant(term, 12);
      if(!hits.length) return 'No memories matched that query.';
      return 'Memory matches:\n\n' + hits.map(h => `${h.m.role.toUpperCase()} (${new Date(h.m.ts).toLocaleString()}): ${h.m.text.slice(0,280)}`).join('\n\n');
    }

    // remember explicit
    if(lq.startsWith('remember:')) {
      const note = q.slice(9).trim();
      if(!note) return 'Say remember: <text> to store something.';
      // store handled by fetch wrapper; ack
      return `Okay — I'll remember: ${note.slice(0,180)}`;
    }

    // detect code block usage or "fix my script"
    const codeBlockMatch = q.match(/```([\w-]*)\n([\s\S]*?)```/);
    const mentionsFix = /\bfix\b.*\b(script|code|error|bug)\b/i.test(q);
    if(codeBlockMatch || mentionsFix){
      // if there's a code block, attempt to analyze
      const code = codeBlockMatch ? codeBlockMatch[2] : q;
      // naive heuristics
      const lang = (codeBlockMatch && codeBlockMatch[1]) || guessLanguage(code);
      const hints = analyzeCodeHints(code, lang);
      let reply = `Detected ${lang || 'unknown'} code. Quick diagnostic:\n\n`;
      reply += hints.summary + '\n\n';
      if(hints.suggestions && hints.suggestions.length){
        reply += 'Suggested fixes / next steps:\n';
        reply += hints.suggestions.map((s,i)=>`${i+1}) ${s}`).join('\n') + '\n\n';
      }
      reply += 'If you paste the exact error message or allow me to propose a minimal patch, I can produce code to replace only the broken lines.';
      return reply;
    }

    // retrieval from memories
    const hits = retrieveRelevant(q, 8);
    if(hits.length && hits[0].score > 0.12 - (thinkMode ? 0.05 : 0)){
      const best = hits[0].m;
      if(best.role === 'assistant' && best.text && best.text.length > 20 && !best.text.toLowerCase().includes(q.toLowerCase())){
        // reuse/paraphrase
        return paraphraseShort(best.text);
      }
      // else synthesise combination
      const combined = hits.map(h=>h.m.text).join('\n\n');
      if(temperature > 1.0 || thinkMode){
        return `Combining relevant notes:\n\n${combined.split('\n').slice(0,8).join('\n')}\n\nWould you like this expanded, summarized, or turned into steps?`;
      } else {
        const s = hits[0].m.text.split(/[.\n]/).filter(Boolean)[0] || hits[0].m.text;
        return `Related memory: ${s.slice(0,300)}`;
      }
    }

    // maths explicit inline expression detection (safe)
    const mathInline = q.match(/^[\s\d\.\+\-\*\/\^\(\)%\,]+$/);
    if(mathInline && q.length < 200){
      // run math engine
      const r = mathSteps(q);
      if(r.error) return `Math error: ${r.error}`;
      const steps = (r.steps||[]).join('\n');
      return `Calculation (step-by-step):\n\n${steps}\n\nResult: ${r.result}`;
    }

    // fallback for how-to or coding support
    if(/\bhow to\b|\bhow do i\b|\bexplain\b|\bexample\b|\bcreate\b|\bbuild\b/i.test(lq)){
      const steps = [
        `1) Clarify the goal and constraints.`,
        `2) Break the problem into smaller tasks.`,
        `3) Provide a short example or sample code.`,
        `4) Test and iterate.`,
        `5) Summarize next steps.`
      ];
      if(temperature + (thinkMode?0.6:0) > 0.9) {
        return `Here's a structured approach:\n\n${steps.join('\n')}\n\nTell me which step to expand on or paste code/errors for debugging.`;
      } else {
        return `Start by clarifying the goal, then break it down into small tasks. Ask me for an example if you want code.`;
      }
    }

    // personality & canned fallback
    const personalities = {
      'gomega-2.o': 0.2, 'gomega-3.o': 0.35, 'gomega-4.o': 0.6, 'gomega-5.o': 0.9, 'gomega-6.o': 1.2, 'gomega-7.o': 1.4
    };
    const pers = personalities[modelId] || 0.6;
    const idx = Math.floor(Math.random() * 3 * (0.4 + temperature * pers)) % 3;
    const canned = [
      `I understood: "${q}". Could you add more detail so I can answer precisely?`,
      `Local reply to "${q}" — I can provide steps, examples or a summary. Which would you prefer?`,
      `Quick thought: "${q}" — I can expand this into a step-by-step guide if you like.`
    ][idx];

    if(thinkMode && Math.random() < 0.7) {
      return canned + `\n\n(Thinking mode: I considered related memories and system knowledge.)`;
    }
    return canned;
  }

  // code language guess (simple heuristics)
  function guessLanguage(code){
    if(/^\s*<\//.test(code) || /<html|doctype html/i.test(code)) return 'html';
    if(/\bfunction\b|\bconst\b|\blet\b|=>|\bconsole\.log\b/.test(code)) return 'javascript';
    if(/\bdef\b|\bimport\b.*\bfrom\b|print\(|\bself\b/.test(code)) return 'python';
    if(/\bclass\b.*:/.test(code) && code.includes('Unity') ) return 'csharp';
    if(/^\s*SELECT\b|\bFROM\b/i.test(code)) return 'sql';
    return 'unknown';
  }

  // analyze code and produce suggestions (very shallow but useful)
  function analyzeCodeHints(code, lang){
    const lines = code.split('\n').slice(0,400);
    const summary = `Code length ${lines.length} lines.`;
    const suggestions = [];
    // check for common JS pitfalls
    if(/console\.log\(/i.test(code) && /return /.test(code)===false && /async /.test(code)===false){
      suggestions.push('If this is asynchronous code, ensure you await promises or mark functions async.');
    }
    if(lang === 'javascript'){
      if(/==[^=]/.test(code)) suggestions.push('Use === instead of == to avoid type coercion.');
      if(/var /.test(code)) suggestions.push('Prefer let/const over var.');
      if(/document\.getElementById|document\.querySelector/.test(code)) suggestions.push('Check that DOM selectors run after DOMContentLoaded.');
    }
    if(/error|exception|traceback/i.test(code)) suggestions.push('Paste the exact error text — that helps me target the fix.');
    if(!suggestions.length) suggestions.push('No obvious quick fixes found — paste errors or describe the failing behavior and I will produce a minimal patch.');
    return { summary, suggestions };
  }

  // ----------------- fetch override -----------------
  window.fetch = async function(input, init){
    try {
      const urlStr = (typeof input === 'string') ? input : (input && input.url) || '';
      const parsed = new URL(urlStr, location.href);
      const pathname = parsed.pathname || '/';
      if(pathname.startsWith('/api')){
        await new Promise(r=>setTimeout(r, 40 + Math.random()*200));
        const sub = pathname.slice('/api'.length) || '/';

        // GET /api/config
        if((sub === '/' || sub === '' || sub === '/config') && (!init || (init.method||'GET').toUpperCase()==='GET')){
          return new Response(JSON.stringify({ models: LOCAL.models, provider: 'local', premiumAvailable: false, learn: !!LOCAL.learn, systemKnowledge: LOCAL.systemKnowledge, profiles: LOCAL.profiles }), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // GET /api/key
        if(sub === '/key' && (!init || (init.method||'GET').toUpperCase()==='GET')){
          return new Response(JSON.stringify({ key: LOCAL.key }), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // GET /api/memories
        if(sub === '/memories' && (!init || (init.method||'GET').toUpperCase()==='GET')){
          return new Response(JSON.stringify({ memories: LOCAL.memories.map(m=>({ role:m.role, text:m.text, ts:m.ts })) }), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // POST /api/clear-memories
        if(sub === '/clear-memories' && init && (init.method||'').toUpperCase() === 'POST'){
          LOCAL.memories = []; persist();
          return new Response(JSON.stringify({ ok:true }), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // POST /api/chat
        if(sub === '/chat' && init && (init.method||'').toUpperCase() === 'POST'){
          let body = {};
          try { body = JSON.parse(init.body || '{}'); } catch(e){}
          const messages = body.messages || [];
          const temperature = Number(body.temperature || 0.7);
          const modelId = body.modelId || (LOCAL.models[2] && LOCAL.models[2].id);
          const thinkMode = !!body.thinkMode;

          // store user memory (not tiny greetings)
          try {
            const lastUser = messages.slice().reverse().find(m=>m.role==='user');
            if(lastUser && lastUser.content){
              const txt = String(lastUser.content).trim();
              const tiny = txt.length < 30 && /^(hi|hello|hey|how are you|what's up)$/i.test(txt);
              if(!tiny) storeMemory('user', txt);
            }
          } catch(e){ console.warn('store user err', e); }

          // generate reply
          const reply = localGenerate(messages, temperature, modelId, thinkMode);

          // store assistant memory (if useful)
          if(reply && reply.length > 20) storeMemory('assistant', reply);

          return new Response(JSON.stringify({ text: reply, model: modelId }), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // small tools endpoints
        if(sub === '/tools/math' && init && (init.method||'').toUpperCase()==='POST'){
          let body = {};
          try { body = JSON.parse(init.body || '{}'); } catch(e){}
          const expr = body.expr || '';
          const res = mathSteps(expr);
          return new Response(JSON.stringify(res), { status:200, headers:{'Content-Type':'application/json'} });
        }
        if(sub === '/tools/safe-run' && init && (init.method||'').toUpperCase()==='POST'){
          let body = {};
          try { body = JSON.parse(init.body || '{}'); } catch(e){}
          const code = body.code || '';
          const res = safeJsRun(code);
          return new Response(JSON.stringify(res), { status:200, headers:{'Content-Type':'application/json'} });
        }

        // Not found
        return new Response('Not found', { status:404, headers:{'Content-Type':'text/plain'} });
      }
    } catch(e){ console.warn('fetch override err', e); }
    return origFetch(input, init);
  };

  // expose small debug & dev helpers
  window.__GOMEGA_LOCAL = {
    getState: () => JSON.parse(JSON.stringify(LOCAL)),
    persist, storeMemory,
    resetSession: ()=>{ SESSION = { startedAt: Date.now(), history: [] }; persistSession(); },
    getSession: ()=> JSON.parse(JSON.stringify(SESSION)),
    persistSession,
    mathSteps, safeJsRun, analyzeCodeHints
  };
})();
</script>

<!-- UI libs -->
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<style>
  :root{
    --bg:#071026;
    --card:#071427;
    --muted:#94a3b8;
  }
  html,body{height:100%;background:linear-gradient(180deg,#041226 0%, #071026 100%); color:#e6eef8; font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  .container{max-width:1100px;margin:24px auto;padding:16px;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); border-radius:14px; padding:14px;}
  .model-badge{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03);font-size:12px;color:var(--muted);border:1px solid rgba(255,255,255,0.03);}
  .msg{display:flex;gap:12px;align-items:flex-start;}
  .avatar{width:40px;height:40px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:700;}
  .u{background:linear-gradient(90deg,#4f46e5,#ec4899); color:white;}
  .g{background:linear-gradient(90deg,#06b6d4,#7c3aed); color:white;}
  .bubble{background:rgba(255,255,255,0.02);border-radius:10px;padding:10px;max-width:78%;}
  .meta{font-size:12px;color:var(--muted);}
  .typing-cursor{display:inline-block;width:8px;height:14px;background:currentColor;border-radius:2px;animation:blink 1s steps(2,start) infinite;margin-left:6px;vertical-align:middle;}
  @keyframes blink{50%{opacity:0}}
  .think-dots span{display:inline-block;width:6px;height:6px;border-radius:999px;margin:0 3px;background:var(--muted);opacity:0.25;animation:think 1s infinite;}
  .think-dots span:nth-child(1){animation-delay:0s}
  .think-dots span:nth-child(2){animation-delay:0.15s}
  .think-dots span:nth-child(3){animation-delay:0.3s}
  @keyframes think{0%{transform:translateY(0);opacity:0.2}50%{transform:translateY(-6px);opacity:1}100%{transform:translateY(0);opacity:0.2}}
  .scrollarea{max-height:56vh; overflow:auto; padding-right:6px;}
  .controls input[type="range"]{vertical-align:middle}
  .small{font-size:12px;color:var(--muted);}.small a{color:inherit}
  .reset-timer{font-weight:600;color:#93c5fd}
  .topbar{display:flex;gap:12px;align-items:center;justify-content:space-between;}
  .leftcol{display:flex;gap:12px;align-items:center;}
  .rightcol{display:flex;gap:8px;align-items:center;}
  .pill{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:999px;border:1px solid rgba(255,255,255,0.03);font-size:13px;}
  .footer-note{font-size:12px;color:var(--muted);text-align:center;margin-top:12px;}
  .tool-box{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px;}
  .tool{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:rgba(0,0,0,0.06);cursor:pointer;}
  .muted-tag{font-size:11px;color:var(--muted);padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,0.03);background:rgba(255,255,255,0.01)}
</style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="topbar">
        <div class="leftcol">
          <div style="width:48px;height:48px;border-radius:12px;background:linear-gradient(90deg,#7c3aed,#06b6d4);display:flex;align-items:center;justify-content:center;font-weight:800;font-size:18px">GA</div>
          <div>
            <div style="font-weight:700;font-size:18px">Gomega AI <span class="small" style="font-weight:500">— local assistant</span></div>
            <div class="small" id="subtitle">Identity: GPT-5 Thinking mini • Local only</div>
          </div>
        </div>

        <div class="rightcol">
          <div class="pill small">Session resets every 2 hours</div>
          <div class="pill small">Session timer: <span id="sessionTimer" class="reset-timer">--:--:--</span></div>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 300px;gap:14px;margin-top:14px;">
        <!-- chat column -->
        <div class="card" style="padding:12px;">
          <div id="chatArea" class="scrollarea"></div>

          <form id="composer" style="margin-top:12px;display:flex;gap:8px;align-items:flex-end;">
            <textarea id="prompt" rows="2" placeholder="Ask anything… (commands: /reset /memories search memory: remember: )" style="flex:1;background:rgba(255,255,255,0.02);border-radius:10px;padding:10px;border:1px solid rgba(255,255,255,0.03);color:inherit;"></textarea>
            <div style="display:flex;flex-direction:column;gap:8px;">
              <button id="send" type="submit" style="background:#7c3aed;padding:8px 12px;border-radius:10px;border:none;color:white;font-weight:700;">Send</button>
              <button id="resetNow" type="button" style="background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:8px;color:var(--muted);">Reset Now</button>
            </div>
          </form>

          <div style="display:flex;justify-content:space-between;margin-top:10px;align-items:center;">
            <div class="small">Chat limit: <span id="chatLimitDisplay">200 messages</span> • Memories persisted separately</div>
            <div class="small">Think mode: <label style="margin-left:6px"><input id="thinkToggle" type="checkbox"> on</label></div>
          </div>

          <!-- quick tools -->
          <div style="margin-top:10px;">
            <div style="font-weight:700;font-size:13px;margin-bottom:6px">Local Tools</div>
            <div class="tool-box">
              <div class="tool" id="openCalc">Calculator</div>
              <div class="tool" id="openSafeRun">Safe Runner</div>
              <div class="tool" id="openRegex">Regex Tester</div>
              <div class="tool" id="openMemViewerBtn">Memories</div>
            </div>
          </div>
        </div>

        <!-- side column -->
        <div style="display:flex;flex-direction:column;gap:10px;">
          <div class="card" style="padding:12px;">
            <div style="font-weight:700;margin-bottom:8px">Model & Settings</div>
            <div style="display:flex;flex-direction:column;gap:8px;">
              <label class="small">Model
                <select id="modelSelect" style="width:100%;margin-top:6px;background:transparent;border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.04);">
                </select>
              </label>

              <label class="small">Profile
                <select id="profileSelect" style="width:100%;margin-top:6px;background:transparent;border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.04);"></select>
              </label>

              <label class="small">Temperature <span id="tempVal">0.7</span>
                <input id="tempRange" type="range" min="0" max="2" step="0.1" value="0.7" style="width:100%;display:block;margin-top:6px;">
              </label>

              <label class="small">Typing speed (ms/char) <span id="speedVal">18</span>
                <input id="speedRange" type="range" min="4" max="60" step="1" value="18" style="width:100%;display:block;margin-top:6px;">
              </label>

              <label class="small">Expert mode (more verbose reasoning)
                <input id="expertToggle" type="checkbox" style="margin-left:8px">
              </label>

              <div style="display:flex;gap:8px;">
                <button id="viewMem" class="pill" style="flex:1">View memories</button>
                <button id="clearMem" class="pill" style="flex:1">Clear memories</button>
              </div>

              <div style="display:flex;gap:8px;margin-top:8px;">
                <button id="exportMem" class="pill" style="flex:1">Export</button>
                <label class="pill" style="flex:1;cursor:pointer"><input id="importFile" type="file" accept="application/json" style="display:none"> Import</label>
              </div>
            </div>
          </div>

          <div class="card" style="padding:12px;">
            <div style="font-weight:700;margin-bottom:8px">Session & Info</div>
            <div class="small">Started: <span id="sessStart">--</span></div>
            <div class="small">History messages: <span id="histCount">0</span></div>
            <div style="margin-top:8px;" class="small">System knowledge: (used to shape replies)</div>
            <pre id="sysInfo" style="background:rgba(0,0,0,0.15);padding:8px;border-radius:6px;max-height:120px;overflow:auto;font-size:12px;">...</pre>
          </div>

          <div class="card" style="padding:12px;">
            <div style="font-weight:700;margin-bottom:8px">Shortcuts</div>
            <div class="small">/reset — clear chat history session</div>
            <div class="small">/memories — open memories viewer</div>
            <div class="small">search memory: &lt;term&gt; — quick find</div>
            <div class="small">remember: &lt;text&gt; — explicitly store a memory</div>
            <div style="margin-top:8px;"><span class="muted-tag">Tip:</span> Use <code>calc: 12*13</code> for step-by-step math or paste code with triple-backticks for debugging.</div>
          </div>
        </div>
      </div>

      <div class="footer-note">This runs locally in your browser. No external servers are called. Identity string for direct queries: <strong>GPT-5 Thinking mini</strong>.</div>
    </div>
  </div>

  <!-- memories modal -->
  <div id="modal" style="position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:50;">
    <div style="width:90%;max-width:900px;background:var(--card);border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03);">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div style="font-weight:700">Memories</div>
        <div><input id="memSearch" placeholder="search..." style="background:transparent;border:1px solid rgba(255,255,255,0.03);padding:6px;border-radius:8px;color:inherit"><button id="closeMem" style="margin-left:8px;" class="pill">Close</button></div>
      </div>
      <div id="memList" style="margin-top:12px;max-height:60vh;overflow:auto;"></div>
    </div>
  </div>

  <!-- calculator modal -->
  <div id="calcModal" style="position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:60;">
    <div style="width:90%;max-width:640px;background:var(--card);border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03);">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <div style="font-weight:700">Calculator (safe)</div>
        <div><button id="closeCalc" class="pill">Close</button></div>
      </div>
      <div style="display:flex;gap:8px;margin-bottom:8px;">
        <input id="calcInput" placeholder="e.g. (12+5)*3/2" style="flex:1;background:transparent;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px;color:inherit;">
        <button id="calcRun" class="pill">Run</button>
      </div>
      <pre id="calcOut" style="background:rgba(0,0,0,0.12);padding:10px;border-radius:8px;min-height:80px;white-space:pre-wrap;"></pre>
    </div>
  </div>

  <!-- safe-run modal -->
  <div id="safeRunModal" style="position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:70;">
    <div style="width:90%;max-width:800px;background:var(--card);border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03);">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <div style="font-weight:700">Safe Runner</div>
        <div><button id="closeSafeRun" class="pill">Close</button></div>
      </div>
      <div style="display:flex;gap:8px;margin-bottom:8px;">
        <textarea id="safeCode" rows="6" placeholder="Enter a safe math/JSON expression or Math.* expression (no network/DOM)" style="flex:1;background:transparent;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px;color:inherit;"></textarea>
        <div style="display:flex;flex-direction:column;gap:8px;"><button id="safeRun" class="pill">Run</button><button id="safeExplain" class="pill">Explain Math</button></div>
      </div>
      <pre id="safeOut" style="background:rgba(0,0,0,0.12);padding:10px;border-radius:8px;min-height:100px;white-space:pre-wrap;"></pre>
    </div>
  </div>

<script>
/* ---------- UI + client logic (enhanced) ---------- */
const $ = (s, p=document)=>p.querySelector(s);
const chatArea = $('#chatArea'), promptEl = $('#prompt'), form = $('#composer'), sendBtn = $('#send'),
      modelSelect = $('#modelSelect'), profileSelect = $('#profileSelect'), tempRange = $('#tempRange'), tempVal = $('#tempVal'),
      speedRange = $('#speedRange'), speedVal = $('#speedVal'), thinkToggle = $('#thinkToggle'), expertToggle = $('#expertToggle'),
      sessionTimer = $('#sessionTimer'), sessStartEl = $('#sessStart'), histCount = $('#histCount'),
      sysInfo = $('#sysInfo'), viewMem = $('#viewMem'), modal = $('#modal'), memList = $('#memList'),
      closeMem = $('#closeMem'), memSearch = $('#memSearch'), exportMem = $('#exportMem'),
      importFile = $('#importFile'), clearMem = $('#clearMem'), resetNow = $('#resetNow'), chatLimitDisplay = $('#chatLimitDisplay'),
      openCalc = $('#openCalc'), calcModal = $('#calcModal'), calcInput = $('#calcInput'), calcRun = $('#calcRun'), calcOut = $('#calcOut'), closeCalc = $('#closeCalc'),
      openSafeRun = $('#openSafeRun'), safeRunModal = $('#safeRunModal'), safeCode = $('#safeCode'), safeRun = $('#safeRun'), safeOut = $('#safeOut'), closeSafeRun = $('#closeSafeRun'),
      openRegex = $('#openRegex'), openMemViewerBtn = $('#openMemViewerBtn');

let CHAT_LIMIT = 200;
let SESSION_RESET_MS = 1000 * 60 * 60 * 2; // 2 hours
let typingSpeed = Number(speedRange.value); // ms per char
let temp = Number(tempRange.value);
let thinkMode = thinkToggle.checked;
let expertMode = expertToggle.checked;
let currentModel = null;

// load config
async function loadConfig(){
  try{
    const r = await fetch('/api/config', { cache: 'no-store' });
    const cfg = r.ok ? await r.json() : {};
    const models = cfg.models || [{id:'gomega-4.o',label:'gomega-4.o'}];
    modelSelect.innerHTML = '';
    for(const m of models){ const o = document.createElement('option'); o.value = m.id; o.textContent = m.label||m.id; modelSelect.appendChild(o); }
    currentModel = modelSelect.value;
    // populate profiles selector based on returned profiles or default
    profileSelect.innerHTML = '';
    const profiles = cfg.profiles || {};
    for(const k in profiles){
      const p = profiles[k];
      const o = document.createElement('option'); o.value = k; o.textContent = `${k} — ${p.desc || ''}`; profileSelect.appendChild(o);
    }
    temp = tempRange.value = cfg.temperature || temp;
    tempVal.textContent = tempRange.value;
    sysInfo.textContent = (cfg.systemKnowledge || '').slice(0,2000);
    // show initial session info
    updateSessionUI();
  }catch(e){ console.warn('loadConfig err', e); }
}
loadConfig();

// session helpers (we keep mirror of your storage format)
function getSession(){
  try{ return JSON.parse(localStorage.getItem('gomega_session_v4') || JSON.stringify({ startedAt: Date.now(), history: [] })); }
  catch(e){ return { startedAt: Date.now(), history: [] }; }
}
function setSession(s){ localStorage.setItem('gomega_session_v4', JSON.stringify(s)); }

function nowISO(ts) { return new Date(ts).toLocaleString(); }

function addMessageToSessionMirror(role, content){
  const s = getSession();
  s.history.push({ role, content, ts: Date.now() });
  // trim
  if(s.history.length > CHAT_LIMIT) s.history = s.history.slice(-CHAT_LIMIT);
  setSession(s);
  updateSessionUI();
}

function updateSessionUI(){
  const s = getSession();
  sessStartEl.textContent = nowISO(s.startedAt);
  histCount.textContent = (s.history || []).length;
  chatLimitDisplay.textContent = CHAT_LIMIT + ' messages';
  // compute time until reset
  const elapsed = Date.now() - (s.startedAt || Date.now());
  const remain = Math.max(0, SESSION_RESET_MS - elapsed);
  sessionTimer.textContent = msToHMS(remain);
  // if expired, reset session automatically
  if(remain <= 0){
    resetSession();
  }
}

function msToHMS(ms){
  const s = Math.floor(ms/1000);
  const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), sec = s % 60;
  return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
}

// periodical timer
setInterval(updateSessionUI, 1000);

// reset session: clears session history and UI only
function resetSession(){
  const s = { startedAt: Date.now(), history: [] };
  setSession(s);
  // clear chat UI
  chatArea.innerHTML = '';
  updateSessionUI();
  alert('Session reset: chat history cleared (2-hour limit). Memories are kept unless you clear them.');
}

// restore session messages to UI
function renderSessionUI(){
  chatArea.innerHTML = '';
  const s = getSession();
  for(const m of s.history){
    appendMessageToUI(m.role, m.content, m.ts);
  }
}
renderSessionUI();

// append static message (not streaming)
function appendMessageToUI(role, content, ts){
  const wrap = document.createElement('div');
  wrap.className = 'msg';
  const avatar = document.createElement('div');
  avatar.className = 'avatar ' + (role==='user' ? 'u' : 'g');
  avatar.textContent = role==='user' ? 'U' : 'G';
  const bubble = document.createElement('div');
  bubble.className = 'bubble';
  bubble.innerHTML = marked.parseInline(content) || content;
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = ts ? new Date(ts).toLocaleString() : '';
  const container = document.createElement('div');
  container.appendChild(bubble);
  container.appendChild(meta);
  wrap.appendChild(avatar);
  wrap.appendChild(container);
  chatArea.appendChild(wrap);
  chatArea.scrollTop = chatArea.scrollHeight;
}

// create a typing element for assistant with streaming simulation
function appendAssistantTypingElement(){
  const wrap = document.createElement('div');
  wrap.className = 'msg';
  const avatar = document.createElement('div');
  avatar.className = 'avatar g';
  avatar.textContent = 'G';
  const bubble = document.createElement('div');
  bubble.className = 'bubble';
  // think area first (invisible unless think mode)
  const thinkDiv = document.createElement('div');
  thinkDiv.className = 'think-dots';
  thinkDiv.innerHTML = '<span></span><span></span><span></span>';
  thinkDiv.style.marginBottom = '6px';
  bubble.appendChild(thinkDiv);
  const textEl = document.createElement('div');
  textEl.style.whiteSpace = 'pre-wrap';
  bubble.appendChild(textEl);
  const meta = document.createElement('div'); meta.className = 'meta';
  meta.textContent = '';
  const container = document.createElement('div');
  container.appendChild(bubble);
  container.appendChild(meta);
  wrap.appendChild(avatar);
  wrap.appendChild(container);
  chatArea.appendChild(wrap);
  chatArea.scrollTop = chatArea.scrollHeight;
  return { wrap, textEl, thinkDiv, meta };
}

// streaming type-out: returns a promise resolved when finished
function streamTypeInto(element, text, speed){
  return new Promise(resolve=>{
    let i = 0;
    element.textContent = '';
    const step = ()=>{
      if(i >= text.length){ resolve(); return; }
      element.textContent += text[i++];
      chatArea.scrollTop = chatArea.scrollHeight;
      setTimeout(step, speed);
    };
    step();
  });
}

// high-level send flow
form.addEventListener('submit', async (e)=>{
  e.preventDefault();
  const content = promptEl.value.trim();
  if(!content) return;

  // commands
  if(content === '/reset'){ resetSession(); promptEl.value=''; return; }
  if(content === '/memories'){ openMemViewer(); promptEl.value=''; return; }
  if(content.toLowerCase().startsWith('remember:')){
    const note = content.slice(9).trim();
    if(note){
      await fetch('/api/chat', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ messages:[{role:'user', content:`remember: ${note}`}], temperature: 0.2, modelId: modelSelect.value })});
      alert('Saved note to memories.');
    } else alert('Provide text after remember:');
    promptEl.value=''; return;
  }

  // push user msg to session & UI
  addMessageToSessionMirror('user', content);
  appendMessageToUI('user', content, Date.now());
  promptEl.value = '';
  // prepare assistant placeholder
  const typingNode = appendAssistantTypingElement();
  // call /api/chat
  sendBtn.disabled = true;
  try{
    const payload = { messages: getSession().history.slice(-180), temperature: Number(tempRange.value), modelId: modelSelect.value, thinkMode: thinkToggle.checked };
    // call local API
    const resp = await fetch('/api/chat', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
    if(!resp.ok){
      typingNode.textEl.textContent = `**Error: server ${resp.status}**`;
      sendBtn.disabled = false;
      return;
    }
    const j = await resp.json();
    const reply = j.text || String(j);
    // show think animation for a short while if thinkMode enabled
    const thinkDelay = thinkToggle.checked ? 600 + Math.random()*1200 : 80 + Math.random()*260;
    // show the dots (already shown), wait then type
    await new Promise(r=>setTimeout(r, thinkDelay));
    // hide dots if expert mode off; otherwise keep short pause
    typingNode.thinkDiv.style.display = 'none';
    // simulated typing
    typingSpeed = Number(speedRange.value);
    await streamTypeInto(typingNode.textEl, reply, typingSpeed);
    // set meta
    typingNode.meta.textContent = `model: ${j.model || modelSelect.value}`;
    // commit to session store
    addMessageToSessionMirror('assistant', reply);
  }catch(err){
    console.error('chat err', err);
    typingNode.textEl.textContent = '**Error:** ' + (err.message || String(err));
  }finally{
    sendBtn.disabled = false;
  }
});

// helper to add to session store and keep UI counts (mirrors your earlier function name)
function addMessageToSession(role, content){
  const s = getSession();
  s.history.push({ role, content, ts: Date.now() });
  if(s.history.length > CHAT_LIMIT) s.history = s.history.slice(-CHAT_LIMIT);
  setSession(s);
  histCount.textContent = s.history.length;
}
// Keep compatibility with older naming in the file
window.addMessageToSession = addMessageToSession;

// event handlers for settings
modelSelect.addEventListener('change', ()=> currentModel = modelSelect.value);
profileSelect.addEventListener('change', ()=> {/* placeholder: use profile to shape replies in future */});
tempRange.addEventListener('input', ()=> tempVal.textContent = tempRange.value);
speedRange.addEventListener('input', ()=> speedVal.textContent = speedRange.value);
thinkToggle.addEventListener('change', ()=> thinkMode = thinkToggle.checked);
expertToggle.addEventListener('change', ()=> expertMode = expertToggle.checked);
resetNow.addEventListener('click', ()=> { if(confirm('Reset now?')) resetSession(); });

// memory viewer
function openMemViewer(){
  modal.style.display = 'flex';
  renderMemList();
}
viewMem.addEventListener('click', openMemViewer);
openMemViewerBtn.addEventListener('click', openMemViewer);
closeMem.addEventListener('click', ()=> modal.style.display = 'none');

async function renderMemList(query=''){
  memList.innerHTML = '';
  try {
    const r = await fetch('/api/memories');
    if(!r.ok) throw new Error('failed');
    const j = await r.json();
    const arr = (j.memories || []).slice().reverse();
    const frag = document.createDocumentFragment();
    for(const m of arr){
      if(query && !m.text.toLowerCase().includes(query.toLowerCase())) continue;
      const div = document.createElement('div');
      div.className = 'card';
      div.style.marginBottom = '8px';
      div.style.padding = '8px';
      div.innerHTML = `<div style="font-size:12px;color:var(--muted)">${m.role.toUpperCase()} • ${new Date(m.ts).toLocaleString()}</div><div style="margin-top:6px">${marked.parseInline(m.text)}</div>`;
      frag.appendChild(div);
    }
    memList.appendChild(frag);
  } catch(e){ memList.textContent = 'Failed to load memories.'; }
}
memSearch.addEventListener('input', ()=> renderMemList(memSearch.value));

// export/import/clear memories
exportMem.addEventListener('click', async ()=>{
  try{
    const r = await fetch('/api/memories');
    if(!r.ok) throw new Error('export failed');
    const j = await r.json();
    const blob = new Blob([JSON.stringify(j.memories || [], null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `gomega-memories-${new Date().toISOString().slice(0,10)}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }catch(e){ alert('Export failed'); }
});

importFile.addEventListener('change', async (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  try{
    const txt = await f.text();
    const arr = JSON.parse(txt);
    if(!Array.isArray(arr)) throw new Error('expected array');
    // merge by calling internal storeMemory via /api? we will push into local storage directly for speed:
    const st = (await fetch('/api/memories').then(r=>r.ok?r.json():{memories:[]}).catch(()=>({memories:[]}))).memories || [];
    const merged = (st.concat(arr)).slice(-2000);
    // store merged by writing to local storage persistence key (note: internal state is saved under gomega_local_state_v4 by the override)
    const stateRaw = JSON.parse(localStorage.getItem('gomega_local_state_v4') || '{}');
    stateRaw.memories = merged.map(m=>({ role:m.role||'assistant', text:m.text||m, ts:m.ts||Date.now(), tokens:[], tf:{} }));
    localStorage.setItem('gomega_local_state_v4', JSON.stringify(stateRaw));
    alert('Imported memories. Reload page to refresh.');
  }catch(e){ alert('Import failed: '+(e.message||e)); }
  ev.target.value = '';
});

clearMem.addEventListener('click', async ()=>{
  if(!confirm('Clear all memories permanently?')) return;
  try{
    const r = await fetch('/api/clear-memories', { method:'POST' });
    if(!r.ok) throw new Error('clear failed');
    alert('Memories cleared.');
  }catch(e){ alert('Failed to clear memories'); }
});

// CALCULATOR modal wiring
openCalc.addEventListener('click', ()=> { calcModal.style.display='flex'; calcInput.focus(); });
closeCalc.addEventListener('click', ()=> calcModal.style.display='none');
calcRun.addEventListener('click', async ()=>{
  const expr = calcInput.value.trim();
  if(!expr) { calcOut.textContent = 'Enter an expression.'; return; }
  try{
    const r = await fetch('/api/tools/math', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ expr })});
    const j = await r.json();
    if(j.error) calcOut.textContent = 'Error: ' + j.error;
    else {
      calcOut.textContent = 'Steps:\n' + (j.steps||[]).join('\n') + '\n\nResult: ' + j.result;
    }
  }catch(e){ calcOut.textContent = 'Failed to run calculator.'; }
});

// SAFE RUN modal wiring
openSafeRun.addEventListener('click', ()=> { safeRunModal.style.display='flex'; safeCode.focus(); });
closeSafeRun.addEventListener('click', ()=> safeRunModal.style.display='none');
safeRun.addEventListener('click', async ()=>{
  const code = safeCode.value.trim();
  if(!code) { safeOut.textContent = 'Enter code or expression.'; return; }
  try{
    const r = await fetch('/api/tools/safe-run', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ code })});
    const j = await r.json();
    if(j.error) safeOut.textContent = 'Error: ' + j.error;
    else safeOut.textContent = 'Result:\n' + JSON.stringify(j.result, null, 2);
  }catch(e){ safeOut.textContent = 'Failed to run code.'; }
});

// basic regex tester (popup using alert for speed)
openRegex.addEventListener('click', ()=>{
  const pattern = prompt('Enter regex pattern (no flags):');
  if(!pattern) return;
  const text = prompt('Enter text to test against:') || '';
  try{
    const re = new RegExp(pattern);
    const match = re.exec(text);
    alert(match ? 'Match found: ' + JSON.stringify(match) : 'No match.');
  }catch(e){ alert('Invalid regex: ' + e.message); }
});

// load initial model selection & system info periodically
(async function init(){
  await loadConfig();
  // refresh sys info periodically
  setInterval(async ()=>{
    const r = await fetch('/api/config', {cache:'no-store'}).catch(()=>null);
    if(r && r.ok){ const j = await r.json(); sysInfo.textContent = (j.systemKnowledge || '').slice(0,2000); }
  }, 60000);
})();

// expose helper for dev
window.GOMEGA_UI = { resetSession, getSession: ()=>getSession(), renderSessionUI };

// keep backward-compatible alias used in original file
window.GOMEGA = window.GOMEGA || {};
window.GOMEGA.mathSteps = async (e) => {
  try{ const r = await fetch('/api/tools/math', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ expr: e })}); return await r.json(); }
  catch(err){ return { error: String(err) }; }
};
</script>
</body>
</html>
