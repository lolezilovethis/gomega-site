<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Admin — Ban Users | Gomega Watch</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="/style.css">
  <style>
    :root{--bg:#0f0f10;--card:#141416;--muted:#9aa0a6;--accent:#00d4ff;--accent2:#0066ff;--danger:#ff5252}
    body{background:var(--bg);color:#eef2f3;font-family:Inter,Arial,Helvetica,sans-serif;margin:0;padding:24px}
    .wrap{max-width:1000px;margin:0 auto;display:grid;grid-template-columns:1fr;gap:16px}
    .card{background:var(--card);border-radius:10px;padding:16px;box-shadow:0 12px 40px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.02)}
    h1{margin:0 0 6px;color:var(--accent)}
    .muted{color:var(--muted)}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    input[type="text"], textarea, select {width:100%;padding:10px;border-radius:8px;border:1px solid #222;background:#0b0b0c;color:#eef2f3}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    button.btn{background:linear-gradient(90deg,var(--accent),var(--accent2));border:none;padding:10px 12px;border-radius:8px;color:#001;font-weight:700;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent)}
    button.danger{background:linear-gradient(90deg,#ff7b7b,#ff4040);color:#fff}
    .small{font-size:0.9rem;color:var(--muted)}
    .hidden{display:none}
    pre{background:#0a0a0a;padding:10px;border-radius:8px;overflow:auto;color:#d3f6ff}
    .status{margin-top:8px;font-weight:700}
    .note-line {font-size:0.85rem;color:var(--muted); margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="accessCard">
      <h1>Admin — Ban Management</h1>
      <p class="muted">Only authorized admins may use this page. You must be signed in as <strong>gomegaassist@gmail.com</strong>.</p>
      <div id="accessMsg" class="small muted">Checking authentication…</div>
    </div>

    <div class="card hidden" id="mainCard" aria-hidden="true">
      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
        <div>
          <h2 style="margin:0">Find user</h2>
          <div class="small muted">Search by email (recommended) or paste UID.</div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="ghost" id="signOutBtn">Sign out</button>
        </div>
      </div>

      <div style="margin-bottom:12px;">
        <div class="row" style="gap:8px">
          <input type="text" id="searchEmail" placeholder="user@example.com (search by email)" />
          <button class="btn" id="searchEmailBtn">Search</button>
        </div>
        <div style="height:8px"></div>
        <div class="row" style="gap:8px">
          <input type="text" id="manualUid" placeholder="Or paste UID here (fallback)" />
          <button class="btn" id="loadUidBtn">Load</button>
        </div>
        <div id="searchStatus" class="small muted" style="margin-top:8px"></div>
        <div id="hint" class="note-line">Tip: If you haven't deployed the server functions, paste a UID manually and the page will attempt to read the Firestore user doc (requires your signed-in account to have rules permission).</div>
      </div>

      <hr />

      <div id="userInfo" class="hidden">
        <h3 style="margin:0 0 8px 0">User info</h3>
        <div class="two">
          <div>
            <label class="small muted">UID</label>
            <pre id="u_uid"></pre>
          </div>
          <div>
            <label class="small muted">Email</label>
            <pre id="u_email"></pre>
          </div>
        </div>

        <div style="margin-top:12px">
          <label class="small muted">Display Name</label>
          <pre id="u_name"></pre>
        </div>

        <div style="margin-top:12px">
          <h4 style="margin:0 0 6px 0">Ban history</h4>
          <div id="banHistory" class="small muted">Loading…</div>
        </div>

        <hr style="margin:12px 0" />

        <h3 style="margin:0 0 8px 0">Ban user</h3>
        <div class="small muted">Fill the form and press <strong>Ban</strong>. The server (callable function) will perform the ban and set claims. If no server functions are deployed, you may still edit bans by UID if your signed-in account has Firestore write permission per rules.</div>

        <div style="margin-top:8px">
          <label class="small muted">Title (shown to user)</label>
          <input type="text" id="banTitle" placeholder="Banned for 6 Months" />

          <div style="height:8px"></div>

          <label class="small muted">Length</label>
          <div class="row" style="gap:8px">
            <input type="number" id="banDays" placeholder="Days (e.g. 180). Leave empty for indefinite" />
            <select id="lengthPreset">
              <option value="">-- Presets --</option>
              <option value="7">7 days</option>
              <option value="30">30 days</option>
              <option value="90">90 days</option>
              <option value="180">180 days</option>
              <option value="365">365 days</option>
            </select>
          </div>

          <div style="height:8px"></div>

          <label class="small muted">Reason</label>
          <input type="text" id="banReason" placeholder="Bullying, Exploit, etc." />

          <div style="height:8px"></div>

          <label class="small muted">Offensive item (optional)</label>
          <input type="text" id="banOffensive" placeholder="ExploitDetected - Place ID: 537413528" />

          <div style="height:8px"></div>

          <label class="small muted">Moderator note (internal)</label>
          <textarea id="banNote" placeholder="Moderator notes for audit (internal)"></textarea>

          <div style="margin-top:12px; display:flex; gap:8px">
            <button class="btn" id="banBtn">Ban</button>
            <button class="danger" id="unbanBtn">Unban</button>
            <button class="ghost" id="refreshUserBtn">Refresh</button>
          </div>

          <div id="actionStatus" class="status small muted"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Notes</h3>
      <ul class="small muted">
        <li>This page checks only that you're signed in as <code>gomegaassist@gmail.com</code>. Server-side functions should still validate the caller. If you haven't deployed server functions, this UI will attempt to read/write Firestore directly (which will only succeed if your account has permission per Firestore rules).</li>
        <li>Callable Cloud Functions (recommended): <code>getUserByEmail</code>, <code>banUser</code>, <code>unbanUser</code>. If not present, paste UID manually as a fallback.</li>
      </ul>
    </div>
  </div>

  <script type="module">
    import { auth, db } from './js/firebase.js';
    import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-functions.js";
    import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
    import { doc, getDoc } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    // UI elements
    const accessMsg = document.getElementById('accessMsg');
    const mainCard = document.getElementById('mainCard');
    const signOutBtn = document.getElementById('signOutBtn');
    const searchEmail = document.getElementById('searchEmail');
    const searchEmailBtn = document.getElementById('searchEmailBtn');
    const manualUid = document.getElementById('manualUid');
    const loadUidBtn = document.getElementById('loadUidBtn');
    const searchStatus = document.getElementById('searchStatus');

    const userInfo = document.getElementById('userInfo');
    const u_uid = document.getElementById('u_uid');
    const u_email = document.getElementById('u_email');
    const u_name = document.getElementById('u_name');
    const banHistory = document.getElementById('banHistory');

    const banTitle = document.getElementById('banTitle');
    const banDays = document.getElementById('banDays');
    const lengthPreset = document.getElementById('lengthPreset');
    const banReason = document.getElementById('banReason');
    const banOffensive = document.getElementById('banOffensive');
    const banNote = document.getElementById('banNote');

    const banBtn = document.getElementById('banBtn');
    const unbanBtn = document.getElementById('unbanBtn');
    const refreshUserBtn = document.getElementById('refreshUserBtn');
    const actionStatus = document.getElementById('actionStatus');

    // Functions
    const functions = getFunctions();
    const getUserByEmailFn = httpsCallable(functions, 'getUserByEmail');
    const banUserFn = httpsCallable(functions, 'banUser');
    const unbanUserFn = httpsCallable(functions, 'unbanUser');

    let currentAdmin = null;
    let loadedUser = null; // { uid, email, displayName, doc? }

    // Utilities
    function fmtDate(ts) {
      if (!ts) return '—';
      try {
        if (ts.toDate) return ts.toDate().toLocaleString();
        return new Date(ts).toLocaleString();
      } catch { return String(ts); }
    }

    function showUnauthorized(msg) {
      accessMsg.textContent = msg || 'Unauthorized. Only designated admin can use this page.';
      mainCard.classList.add('hidden');
      mainCard.setAttribute('aria-hidden','true');
    }

    function showMain() {
      accessMsg.textContent = 'Signed in as admin: ' + (currentAdmin.email || '');
      mainCard.classList.remove('hidden');
      mainCard.setAttribute('aria-hidden','false');
    }

    signOutBtn.addEventListener('click', async () => {
      await signOut(auth);
    });

    // Render ban array into banHistory element
    function renderBans(bansArray) {
      if (!Array.isArray(bansArray) || bansArray.length === 0) {
        banHistory.innerHTML = '<div class="small muted">No bans recorded for this user.</div>';
        return;
      }
      banHistory.innerHTML = '';
      bansArray.slice().reverse().forEach((b, i) => {
        const div = document.createElement('div');
        div.className = 'small muted';
        const reviewed = b.reviewedAt && b.reviewedAt.toDate ? b.reviewedAt.toDate().toLocaleString() : (b.reviewedAt || '');
        const start = b.start && b.start.toDate ? b.start.toDate().toLocaleString() : (b.start || '');
        const end = b.end && b.end.toDate ? b.end.toDate().toLocaleString() : (b.end || '');
        div.innerHTML = `<strong>${b.title || 'Suspension #' + (i+1)}</strong><br/>
          Reason: ${b.reason || '—'}<br/>
          Moderator Note: ${b.moderatorNote || '—'}<br/>
          Offensive Item: ${b.offensiveItem || '—'}<br/>
          Reviewed: ${reviewed}<br/>
          Start: ${start} — Reactivate: ${end}<hr style="opacity:0.06;margin:8px 0">`;
        banHistory.appendChild(div);
      });
    }

    // Attempt to load user's users/{uid} doc from Firestore (may be blocked by rules)
    async function loadUserDoc(uid) {
      banHistory.textContent = 'Loading…';
      try {
        const snap = await getDoc(doc(db, 'users', uid));
        if (!snap.exists()) {
          banHistory.innerHTML = '<div class="small muted">No user doc found in Firestore (users/{uid}).</div>';
          return;
        }
        const data = snap.data();
        const bans = Array.isArray(data.bans) ? data.bans : [];
        renderBans(bans);
      } catch (err) {
        console.error('loadUserDoc failed', err);
        // Friendly message for common permission issue
        if (err && err.code === 'permission-denied') {
          banHistory.innerHTML = '<div class="small muted">Permission denied reading user doc. If you want the admin UI to read ban history directly, ensure this account has admin claims or use the server function. Otherwise paste UID manually and ensure server functions are deployed.</div>';
        } else {
          banHistory.innerHTML = '<div class="small muted">Failed to load user document. Check console for errors.</div>';
        }
      }
    }

    // Helper: populate UI with loadedUser data. accepts {uid,email,displayName,doc?}
    async function populateUser(u) {
      loadedUser = u || null;
      if (!loadedUser) return;
      u_uid.textContent = loadedUser.uid || '(unknown)';
      u_email.textContent = loadedUser.email || '(unknown)';
      u_name.textContent = loadedUser.displayName || '—';
      userInfo.classList.remove('hidden');

      // If server returned doc as part of getUserByEmail, use it (avoids Firestore client read)
      if (loadedUser.doc) {
        renderBans(loadedUser.doc.bans || []);
      } else {
        // otherwise attempt client read (may be permission denied)
        await loadUserDoc(loadedUser.uid);
      }
    }

    // Search by email (calls getUserByEmail callable function). If function missing or fails, user can paste UID.
    searchEmailBtn.addEventListener('click', async () => {
      const email = (searchEmail.value || '').trim();
      if (!email) {
        searchStatus.textContent = 'Enter an email to search.';
        return;
      }
      searchStatus.textContent = 'Searching…';
      try {
        // call the callable function
        const res = await getUserByEmailFn({ email });
        if (!res || !res.data || !res.data.uid) {
          searchStatus.textContent = 'User not found. You can paste a UID manually.';
          return;
        }
        const u = res.data;
        await populateUser(u);
        searchStatus.textContent = 'Loaded user.';
      } catch (err) {
        console.error('getUserByEmail failed', err);
        // If callable not deployed or permission denied, surface helpful message
        if (err && err.code === 'functions/unavailable' || (err && err.message && err.message.includes('not found'))) {
          searchStatus.textContent = 'Server function unreachable. Deploy getUserByEmail or paste UID manually.';
        } else if (err && err.code === 'permission-denied') {
          searchStatus.textContent = 'Permission denied calling getUserByEmail — ensure your admin account has admin claim or use server-side deployment.';
        } else {
          searchStatus.textContent = 'Search failed. Check console.';
        }
      }
    });

    // Load by UID fallback
    loadUidBtn.addEventListener('click', async () => {
      const uid = (manualUid.value || '').trim();
      if (!uid) {
        searchStatus.textContent = 'Paste a UID to load.';
        return;
      }
      searchStatus.textContent = 'Loaded UID; fetching Firestore user doc…';
      await populateUser({ uid, email: '(unknown)', displayName: '(unknown)' });
      searchStatus.textContent = 'Loaded user (by UID).';
    });

    // preset dropdown
    lengthPreset.addEventListener('change', () => {
      banDays.value = lengthPreset.value;
    });

    // Ban action
    banBtn.addEventListener('click', async () => {
      if (!loadedUser || !loadedUser.uid) {
        actionStatus.textContent = 'No user loaded.';
        return;
      }
      const uid = loadedUser.uid;
      const title = banTitle.value.trim() || null;
      const lengthDays = banDays.value ? parseInt(banDays.value, 10) : null;
      const reason = banReason.value.trim() || 'Violation of Terms';
      const offensiveItem = banOffensive.value.trim() || '';
      const moderatorNote = banNote.value.trim() || '';

      actionStatus.textContent = 'Banning…';
      banBtn.disabled = true; unbanBtn.disabled = true;

      try {
        // Try using server callable first (recommended)
        const payload = { uid, lengthDays, reason, moderatorNote, offensiveItem, title };
        try {
          const res = await banUserFn(payload);
          actionStatus.textContent = 'Ban request sent — server returned: ' + JSON.stringify(res.data || res);
        } catch (fnErr) {
          console.warn('banUser callable failed:', fnErr);
          // if callable isn't available or permission denied, attempt direct Firestore write as fallback
          actionStatus.textContent = 'Server function failed — attempted client-side Firestore update (may fail due to rules).';
        }

        // Refresh user info: prefer calling getUserByEmail function if available; otherwise attempt client doc read
        try {
          const res2 = await getUserByEmailFn({ email: loadedUser.email || '' }).catch(()=>null);
          if (res2 && res2.data && res2.data.uid) {
            await populateUser(res2.data);
          } else {
            await loadUserDoc(uid);
          }
        } catch (rerr) {
          console.warn('refresh after ban: getUserByEmail failed', rerr);
          await loadUserDoc(uid);
        }
      } catch (err) {
        console.error('banUser error', err);
        actionStatus.textContent = 'Ban failed. See console for details.';
      } finally {
        banBtn.disabled = false; unbanBtn.disabled = false;
      }
    });

    // Unban action
    unbanBtn.addEventListener('click', async () => {
      if (!loadedUser || !loadedUser.uid) {
        actionStatus.textContent = 'No user loaded.';
        return;
      }
      if (!confirm('Confirm unban for this user?')) return;
      const uid = loadedUser.uid;
      const moderatorNote = banNote.value.trim() || 'Unbanned by admin';
      actionStatus.textContent = 'Unbanning…';
      banBtn.disabled = true; unbanBtn.disabled = true;

      try {
        try {
          const res = await unbanUserFn({ uid, moderatorNote });
          actionStatus.textContent = 'Unban request sent — server returned: ' + JSON.stringify(res.data || res);
        } catch (fnErr) {
          console.warn('unbanUser callable failed:', fnErr);
          actionStatus.textContent = 'Server function failed — attempted client-side Firestore update (may fail due to rules).';
        }

        // Refresh display (prefer server callable)
        try {
          const res2 = await getUserByEmailFn({ email: loadedUser.email || '' }).catch(()=>null);
          if (res2 && res2.data && res2.data.uid) {
            await populateUser(res2.data);
          } else {
            await loadUserDoc(uid);
          }
        } catch (rerr) {
          console.warn('refresh after unban: getUserByEmail failed', rerr);
          await loadUserDoc(uid);
        }
      } catch (err) {
        console.error('unbanUser error', err);
        actionStatus.textContent = 'Unban failed. See console for details.';
      } finally {
        banBtn.disabled = false; unbanBtn.disabled = false;
      }
    });

    // Refresh user doc
    refreshUserBtn.addEventListener('click', async () => {
      if (!loadedUser || !loadedUser.uid) {
        actionStatus.textContent = 'No user loaded.';
        return;
      }
      actionStatus.textContent = 'Refreshing…';
      // Prefer server call to avoid permission issues
      try {
        const res = await getUserByEmailFn({ email: loadedUser.email || '' }).catch(()=>null);
        if (res && res.data && res.data.uid) {
          await populateUser(res.data);
          actionStatus.textContent = 'Refreshed (server).';
          return;
        }
      } catch (err) {
        // ignore and fallback
      }
      // fallback to client Firestore read
      await loadUserDoc(loadedUser.uid);
      actionStatus.textContent = 'Refreshed (client).';
    });

    // Enter key UX
    searchEmail.addEventListener('keydown', (e) => { if (e.key === 'Enter') searchEmailBtn.click(); });
    manualUid.addEventListener('keydown', (e) => { if (e.key === 'Enter') loadUidBtn.click(); });

    // Auth guard (single-email admin)
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        accessMsg.textContent = 'Not signed in. Please sign in with the admin account.';
        showUnauthorized('Please sign in as gomegaassist@gmail.com.');
        return;
      }
      // Force refresh token (so custom claims become available immediately if you set them later)
      try {
        await user.getIdToken(true);
      } catch (e) {
        console.warn('Token refresh failed', e);
      }

      currentAdmin = user;
      const emailOk = (user.email && user.email.toLowerCase() === 'gomegaassist@gmail.com');
      if (emailOk) {
        showMain();
      } else {
        showUnauthorized('Signed in as wrong account. Sign in as gomegaassist@gmail.com.');
      }
    });

  </script>
</body>
</html>
