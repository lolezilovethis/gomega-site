<!-- chat.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gomega Chat</title>
  <style>
    :root { --blue:#0b57cc; --bg:#f6f7fb; --card:#ffffff; --muted:#666; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:0; background:var(--bg); color:#111; }
    header { display:flex; align-items:center; justify-content:space-between; padding:12px 18px; background:var(--blue); color:white; }
    header .brand { font-weight:700; font-size:18px; }
    .container { display:flex; gap:18px; padding:18px; }
    .left, .right { background:var(--card); border-radius:12px; padding:12px; box-shadow:0 6px 18px rgba(12,20,40,0.06); }
    .left { flex: 1 1 640px; display:flex; flex-direction:column; height:75vh; }
    .public-messages { flex:1; overflow:auto; padding:8px; border-radius:8px; background:#fbfdff; }
    .message { padding:8px; margin-bottom:8px; border-radius:8px; border:1px solid rgba(15,20,40,0.04); }
    .controls { display:flex; gap:8px; margin-top:8px; }
    input[type="text"], textarea { width:100%; padding:8px; border-radius:8px; border:1px solid #e3e7ef; font-size:14px; }
    button { padding:8px 12px; border-radius:8px; border:0; cursor:pointer; background:var(--blue); color:white; }
    .right { width:320px; display:flex; flex-direction:column; gap:12px; height:75vh; }
    .users-list { overflow:auto; flex:1; }
    .user { padding:8px; display:flex; justify-content:space-between; border-radius:8px; border:1px solid rgba(15,20,40,0.04); margin-bottom:8px; align-items:center; }
    .private-view { display:none; flex-direction:column; gap:8px; height:75vh; }
    .private-messages { flex:1; overflow:auto; padding:8px; background:#fff; border-radius:8px; }
    .small { font-size:12px; color:var(--muted); }
    .reply { font-size:12px; color:var(--blue); cursor:pointer; text-decoration:underline; background:none; border:none; padding:0; }
    .modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.35); }
    .modal .card { background:var(--card); padding:16px; border-radius:12px; width:420px; max-height:80vh; overflow:auto; }
    .topbar { display:flex; gap:8px; align-items:center; }
    .msg-you { background:#eaf6ff; padding:8px; border-radius:8px; margin-bottom:6px; }
    .msg-other { background:#f3f3f5; padding:8px; border-radius:8px; margin-bottom:6px; }
    .muted { color:var(--muted); font-size:12px; }
    .dm-list { overflow:auto; max-height:40vh; }

    /* Typing indicator */
    .typing-area { min-height:24px; display:flex; align-items:center; gap:8px; padding:4px 2px; color:var(--muted); font-size:13px; }
    .dots { display:inline-block; width:30px; text-align:left; }
    .dots span { display:inline-block; width:6px; height:6px; margin-right:4px; border-radius:50%; background:var(--blue); opacity:0.25; animation: blink 1s infinite; }
    .dots span:nth-child(2) { animation-delay:0.15s; }
    .dots span:nth-child(3) { animation-delay:0.3s; }
    @keyframes blink { 0%{opacity:0.25;} 50%{opacity:1;} 100%{opacity:0.25;} }

    .typing-names { font-weight:600; color:#0b57cc; }
  </style>
</head>
<body>

<header>
  <div class="brand">Gomega Chat</div>
  <div class="topbar">
    <span id="userDisplay" class="small muted"></span>
    <button id="signInBtn">Sign in</button>
    <button id="signOutBtn" style="display:none">Sign out</button>
  </div>
</header>

<div class="container">
  <div class="left" id="mainLeft">

    <!-- Public Chat Header -->
    <div id="publicHeader" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
      <strong>Public Chat</strong>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="openDmsBtn">My DMs</button>
      </div>
    </div>

    <!-- Public messages -->
    <div id="publicArea">
      <div class="public-messages" id="publicMessages" aria-live="polite"></div>

      <!-- typing indicator for public -->
      <div id="publicTyping" class="typing-area" aria-hidden="true"></div>

      <div class="controls">
        <input id="messageInput" type="text" placeholder="Say something to everyone..." autocomplete="off" />
        <button id="sendBtn">Send</button>
      </div>
    </div>

    <!-- Private view (shown when in private chat) -->
    <div id="privateView" class="private-view" role="region" aria-hidden="true">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <button id="backToPublicBtn" style="background:transparent;color:white;background-color:var(--blue);border-radius:8px;padding:6px 10px;">Back to public chat</button>
        </div>
        <div>
          <strong id="privateWith">Private Chat</strong>
          <div id="privateWithSmall" class="small"></div>
        </div>
        <div style="width:60px"></div>
      </div>

      <div class="private-messages" id="privateMessages" aria-live="polite"></div>

      <!-- typing indicator for private -->
      <div id="privateTyping" class="typing-area" aria-hidden="true"></div>

      <div style="display:flex; gap:8px; margin-top:8px;">
        <input id="privateInput" type="text" placeholder="Send a private message..." autocomplete="off" />
        <button id="sendPrivateBtn">Send</button>
      </div>
    </div>

  </div>

  <div class="right">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <strong>Active Users</strong>
      <div class="small muted">Click name → Private Chat</div>
    </div>

    <div class="users-list" id="usersList"></div>

    <div style="margin-top:8px;"><strong>My DMs</strong></div>
    <div class="dm-list" id="dmList"></div>
    <div class="small" style="margin-top:8px;">Private messages auto-expire after 12 days (enable Firestore TTL on expireAt).</div>
  </div>
</div>

<script type="module">
/* chat.html with typing indicators, Enter-to-send, and smooth autoscroll.
   Uses ./js/firebase.js (exports { auth, db, provider }).
*/

import { auth, db, provider } from './js/firebase.js';
import { signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
import {
  collection, addDoc, serverTimestamp, query, orderBy, onSnapshot,
  where, Timestamp, doc, setDoc, deleteDoc, getDocs, limit, collectionGroup
} from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

/* UI elements */
const signInBtn = document.getElementById('signInBtn');
const signOutBtn = document.getElementById('signOutBtn');
const userDisplay = document.getElementById('userDisplay');

const publicMessagesDiv = document.getElementById('publicMessages');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');

const usersList = document.getElementById('usersList');

const openDmsBtn = document.getElementById('openDmsBtn');
const dmList = document.getElementById('dmList');

const privateView = document.getElementById('privateView');
const privateMessagesDiv = document.getElementById('privateMessages');
const privateInput = document.getElementById('privateInput');
const sendPrivateBtn = document.getElementById('sendPrivateBtn');
const privateWith = document.getElementById('privateWith');
const privateWithSmall = document.getElementById('privateWithSmall');
const backToPublicBtn = document.getElementById('backToPublicBtn');

const publicArea = document.getElementById('publicArea');
const publicHeader = document.getElementById('publicHeader');

const publicTypingDiv = document.getElementById('publicTyping');
const privateTypingDiv = document.getElementById('privateTyping');

let currentUser = null;
let publicUnsub = null;
let usersUnsub = null;
let privateUnsub = null;
let dmsUnsub = null;

let currentPrivateChatId = null;
let currentPrivatePeer = null; // { uid, displayName }

/* TYPING CONFIG */
const TYPING_COLLECTION_PUBLIC = 'publicTyping'; // docs: /publicTyping/{uid}
const TYPING_EXPIRY_SECONDS = 5; // show typing entries updated within this many seconds
let lastPublicTypingUpdate = 0;
let lastPrivateTypingUpdate = 0;

/* AUTH */
signInBtn.onclick = async () => {
  try { await signInWithPopup(auth, provider); } catch (e) { console.error('signin', e); alert('Sign-in failed'); }
};
signOutBtn.onclick = async () => {
  try { await signOut(auth); } catch (e) { console.error('signout', e); }
};

onAuthStateChanged(auth, async (user) => {
  if (user) {
    currentUser = user;
    userDisplay.textContent = `${user.displayName || user.email || user.uid}`;
    signInBtn.style.display = 'none';
    signOutBtn.style.display = '';
    try {
      await setDoc(doc(collection(db, 'users'), user.uid), {
        uid: user.uid,
        displayName: user.displayName || '',
        email: user.email || '',
        lastSeen: serverTimestamp()
      }, { merge: true });
    } catch (err) { console.error('user doc write error', err); }
    startPublicListener();
    startUsersListener();
    startDmsListener();
    startPublicTypingListener();
  } else {
    currentUser = null;
    userDisplay.textContent = '';
    signInBtn.style.display = '';
    signOutBtn.style.display = 'none';
    unsubscribeAll();
    publicMessagesDiv.innerHTML = '';
    usersList.innerHTML = '';
    dmList.innerHTML = '';
    showPublicView();
  }
});

function unsubscribeAll() {
  if (publicUnsub) publicUnsub(); publicUnsub = null;
  if (usersUnsub) usersUnsub(); usersUnsub = null;
  if (privateUnsub) privateUnsub(); privateUnsub = null;
  if (dmsUnsub) dmsUnsub(); dmsUnsub = null;
  stopPublicTypingUpdates();
  stopPrivateTypingUpdates();
}

/* PUBLIC CHAT (7 days) */
function startPublicListener() {
  if (publicUnsub) publicUnsub();
  const sevenDaysAgo = Timestamp.fromDate(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000));
  const q = query(collection(db, 'publicMessages'), where('createdAt', '>=', sevenDaysAgo), orderBy('createdAt', 'asc'), limit(1000));
  publicUnsub = onSnapshot(q, (snap) => {
    const prevScroll = publicMessagesDiv.scrollTop + publicMessagesDiv.clientHeight;
    const wasAtBottom = (Math.abs(prevScroll - publicMessagesDiv.scrollHeight) < 50);
    publicMessagesDiv.innerHTML = '';
    snap.forEach(docSnap => {
      const m = docSnap.data();
      renderPublicMessage(docSnap.id, m);
    });
    // auto-scroll: if user is viewing near bottom or new message added, scroll to bottom smoothly
    if (wasAtBottom || snap.docChanges().some(ch => ch.type === 'added')) {
      scrollToBottom(publicMessagesDiv);
    }
  }, (err) => {
    console.error('public listener', err);
    publicMessagesDiv.innerHTML = '<div class="muted">Cannot load public chat.</div>';
  });
}

function renderPublicMessage(id, m) {
  const div = document.createElement('div');
  div.className = 'message';
  const name = m.displayName || m.email || 'Unknown';
  const time = m.createdAt ? new Date(m.createdAt.seconds * 1000).toLocaleString() : '...';
  div.innerHTML = `
    <div style="display:flex; justify-content:space-between; gap:8px;">
      <div>
        <strong style="cursor:pointer" data-uid="${escapeHtml(m.uid || '')}" data-name="${escapeHtml(name)}">${escapeHtml(name)}</strong>
        <div class="small">${escapeHtml(time)}</div>
      </div>
      <div class="small">#${id.slice(0,6)}</div>
    </div>
    <div style="margin-top:8px;">${escapeHtml(m.text || '')}</div>
    <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
      <button class="reply" data-id="${id}">Reply</button>
      <button class="reply private-from-public" data-user="${escapeHtml(m.uid || '')}" data-name="${escapeHtml(name)}">Private Chat</button>
    </div>
  `;
  publicMessagesDiv.appendChild(div);

  // hooks
  div.querySelectorAll('strong[data-uid]').forEach(node => {
    node.onclick = () => openPrivateChat(node.dataset.uid, node.dataset.name);
  });
  div.querySelectorAll('button.private-from-public[data-user]').forEach(b => {
    b.onclick = () => openPrivateChat(b.dataset.user, b.dataset.name);
  });
}

/* send public (Enter to send) */
async function sendPublicMessage() {
  if (!currentUser) { alert('Sign in first'); return; }
  const text = messageInput.value.trim();
  if (!text) return;
  const payload = {
    uid: currentUser.uid,
    displayName: currentUser.displayName || '',
    email: currentUser.email || '',
    text,
    parentId: null,
    createdAt: Timestamp.now(),
    expireAt: Timestamp.fromDate(new Date(Date.now() + 12 * 24 * 60 * 60 * 1000))
  };
  try {
    await addDoc(collection(db, 'publicMessages'), payload);
    messageInput.value = '';
    // remove typing state
    await removePublicTyping(); // best-effort
  } catch (err) {
    console.error('send public message error', err);
    alert('Failed to send public message.');
  }
}

sendBtn.onclick = sendPublicMessage;

// Enter key send (public)
messageInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendPublicMessage(); }
  else { schedulePublicTypingUpdate(); }
});
messageInput.addEventListener('input', () => schedulePublicTypingUpdate());
messageInput.addEventListener('blur', () => removePublicTyping());

/* USERS LIST */
function startUsersListener() {
  if (usersUnsub) usersUnsub();
  const q = query(collection(db, 'users'), orderBy('lastSeen', 'desc'), limit(200));
  usersUnsub = onSnapshot(q, (snap) => {
    usersList.innerHTML = '';
    snap.forEach(s => {
      const u = s.data();
      const div = document.createElement('div');
      div.className = 'user';
      div.innerHTML = `<div>
          <div style="font-weight:600">${escapeHtml(u.displayName || u.email || 'Unknown')}</div>
          <div class="small">${escapeHtml(u.email || '')}</div>
        </div>
        <div style="display:flex; flex-direction:column; gap:6px;">
          <button class="pc" data-uid="${escapeHtml(u.uid || '')}" data-name="${escapeHtml(u.displayName || '')}">Private Chat</button>
        </div>`;
      usersList.appendChild(div);
    });

    document.querySelectorAll('button.pc').forEach(b => {
      b.onclick = () => openPrivateChat(b.dataset.uid, b.dataset.name);
    });
  }, (err) => {
    console.error('users listener', err);
    usersList.innerHTML = '<div class="muted">Cannot load active users.</div>';
  });
}

/* PRIVATE CHAT UTILITIES */
function privateChatId(uid1, uid2) {
  return [uid1, uid2].sort().join('_');
}

function openPrivateChat(peerUid, peerName) {
  if (!currentUser) return alert('Sign in first');
  if (!peerUid) return alert('Invalid user');
  if (peerUid === currentUser.uid) return alert('Cannot open private chat with yourself.');
  currentPrivateChatId = privateChatId(currentUser.uid, peerUid);
  currentPrivatePeer = { uid: peerUid, displayName: peerName || '' };
  showPrivateView(peerUid, peerName);
  loadPrivateMessages(currentPrivateChatId);
  startPrivateTypingListener(currentPrivateChatId);
}

function showPrivateView(peerUid, peerName) {
  publicArea.style.display = 'none';
  publicHeader.style.display = 'none';
  privateView.style.display = 'flex';
  privateView.setAttribute('aria-hidden', 'false');
  privateWith.textContent = `Chat with ${peerName || peerUid}`;
  privateWithSmall.textContent = peerUid;
}

function showPublicView() {
  privateView.style.display = 'none';
  privateView.setAttribute('aria-hidden', 'true');
  publicArea.style.display = '';
  publicHeader.style.display = '';
  currentPrivateChatId = null;
  currentPrivatePeer = null;
  if (privateUnsub) { privateUnsub(); privateUnsub = null; }
  privateMessagesDiv.innerHTML = '';
  stopPrivateTypingUpdates();
}

backToPublicBtn.onclick = showPublicView;

/* Load private messages */
function loadPrivateMessages(chatId) {
  if (privateUnsub) privateUnsub();
  const messagesCol = collection(db, 'privateChats', chatId, 'messages');
  const twelveDaysAgo = Timestamp.fromDate(new Date(Date.now() - 12 * 24 * 60 * 60 * 1000));
  const q = query(messagesCol, where('createdAt', '>=', twelveDaysAgo), orderBy('createdAt', 'asc'));
  privateUnsub = onSnapshot(q, (snap) => {
    const wasAtBottom = Math.abs((privateMessagesDiv.scrollTop + privateMessagesDiv.clientHeight) - privateMessagesDiv.scrollHeight) < 50;
    privateMessagesDiv.innerHTML = '';
    snap.forEach(s => {
      const m = s.data();
      const isMe = m.uid === currentUser.uid;
      const wrapper = document.createElement('div');
      wrapper.className = isMe ? 'msg-you' : 'msg-other';
      const t = m.createdAt ? new Date(m.createdAt.seconds * 1000).toLocaleString() : '...';
      wrapper.innerHTML = `<div class="small"><strong>${escapeHtml(m.displayName || m.email)}</strong> • ${escapeHtml(t)}</div><div>${escapeHtml(m.text || '')}</div>`;
      privateMessagesDiv.appendChild(wrapper);
    });
    if (wasAtBottom || snap.docChanges().some(ch => ch.type === 'added')) {
      scrollToBottom(privateMessagesDiv);
    }
  }, (err) => {
    console.error('private messages listener', err);
    privateMessagesDiv.innerHTML = '<div class="muted">Cannot load private messages.</div>';
  });
}

/* send private (Enter to send) */
async function sendPrivateMessage() {
  if (!currentUser || !currentPrivateChatId || !currentPrivatePeer) return alert('Open a private chat first');
  const txt = privateInput.value.trim();
  if (!txt) return;
  const messagesCol = collection(db, 'privateChats', currentPrivateChatId, 'messages');
  const payload = {
    uid: currentUser.uid,
    displayName: currentUser.displayName || '',
    email: currentUser.email || '',
    text: txt,
    createdAt: Timestamp.now(),
    expireAt: Timestamp.fromDate(new Date(Date.now() + 12 * 24 * 60 * 60 * 1000))
  };
  try {
    await addDoc(messagesCol, payload);
    privateInput.value = '';
    // remove typing state within private chat
    await removePrivateTyping(currentPrivateChatId);
  } catch (err) {
    console.error('send private msg', err);
    alert('Failed to send private message.');
  }
}
sendPrivateBtn.onclick = sendPrivateMessage;
privateInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendPrivateMessage(); }
  else { schedulePrivateTypingUpdate(); }
});
privateInput.addEventListener('input', () => schedulePrivateTypingUpdate());
privateInput.addEventListener('blur', () => {
  if (currentPrivateChatId) removePrivateTyping(currentPrivateChatId);
});

/* My DMs (collectionGroup) */
function startDmsListener() {
  if (!currentUser) return;
  if (dmsUnsub) dmsUnsub();
  const twelveDaysAgo = Timestamp.fromDate(new Date(Date.now() - 12 * 24 * 60 * 60 * 1000));
  const cg = collectionGroup(db, 'messages');
  const q = query(cg, where('createdAt', '>=', twelveDaysAgo), orderBy('createdAt', 'desc'), limit(1000));
  dmsUnsub = onSnapshot(q, async (snap) => {
    const chatMap = new Map();
    for (const docSnap of snap.docs) {
      const pathParts = docSnap.ref.path.split('/');
      if (pathParts.length < 3) continue;
      const chatId = pathParts[1];
      if (!chatMap.has(chatId)) chatMap.set(chatId, docSnap);
    }
    dmList.innerHTML = '';
    for (const [chatId, docSnap] of chatMap) {
      const m = docSnap.data();
      const uids = chatId.split('_');
      const otherUid = uids[0] === currentUser.uid ? uids[1] : uids[0];
      let otherName = otherUid;
      try {
        const userDoc = await getDocs(query(collection(db, 'users'), where('uid', '==', otherUid), limit(1)));
        if (!userDoc.empty) {
          const ud = userDoc.docs[0].data();
          otherName = ud.displayName || ud.email || otherUid;
        }
      } catch (e) { /* ignore */ }
      const row = document.createElement('div');
      row.style = "padding:8px; border-bottom:1px solid #f0f2f6; cursor:pointer;";
      const time = m.createdAt ? new Date(m.createdAt.seconds * 1000).toLocaleString() : '...';
      row.innerHTML = `<div style="font-weight:600">${escapeHtml(otherName)}</div><div class="small">${escapeHtml(m.text || '')}</div><div class="small muted">${escapeHtml(time)}</div>`;
      row.onclick = () => openPrivateChat(otherUid, otherName);
      dmList.appendChild(row);
    }
  }, (err) => {
    console.error('dms listener', err);
    dmList.innerHTML = '<div class="muted">Cannot load DMs.</div>';
  });
}

/* TYPING: PUBLIC */

let publicTypingInterval = null;
async function schedulePublicTypingUpdate() {
  if (!currentUser) return;
  const now = Date.now();
  if (now - lastPublicTypingUpdate < 2000) return; // throttle to 2s
  lastPublicTypingUpdate = now;
  try {
    await setDoc(doc(db, TYPING_COLLECTION_PUBLIC, currentUser.uid), {
      uid: currentUser.uid,
      displayName: currentUser.displayName || '',
      updatedAt: serverTimestamp()
    }, { merge: true });
    // start periodic refresh to keep entry alive while typing (client will update periodically while typing)
    if (!publicTypingInterval) publicTypingInterval = setInterval(() => {
      setDoc(doc(db, TYPING_COLLECTION_PUBLIC, currentUser.uid), {
        uid: currentUser.uid,
        displayName: currentUser.displayName || '',
        updatedAt: serverTimestamp()
      }, { merge: true }).catch(() => {});
    }, 3000);
  } catch (e) {
    /* ignore errors */
  }
}

async function removePublicTyping() {
  if (!currentUser) return;
  try {
    await deleteDoc(doc(db, TYPING_COLLECTION_PUBLIC, currentUser.uid));
  } catch (e) {}
  stopPublicTypingUpdates();
}

function stopPublicTypingUpdates() {
  if (publicTypingInterval) { clearInterval(publicTypingInterval); publicTypingInterval = null; }
}

/* listen for public typing entries */
function startPublicTypingListener() {
  const q = collection(db, TYPING_COLLECTION_PUBLIC);
  onSnapshot(q, (snap) => {
    const nowTs = Timestamp.now();
    const active = [];
    snap.forEach(s => {
      const d = s.data();
      if (d.updatedAt && (nowTs.seconds - d.updatedAt.seconds) <= TYPING_EXPIRY_SECONDS) {
        if (d.uid !== (currentUser && currentUser.uid)) active.push({ uid: d.uid, displayName: d.displayName || d.uid });
      }
    });
    renderTyping(publicTypingDiv, active);
  }, (err) => {
    // ignore typing errors
  });
}

/* TYPING: PRIVATE */
let privateTypingInterval = null;
async function schedulePrivateTypingUpdate() {
  if (!currentUser || !currentPrivateChatId) return;
  const now = Date.now();
  if (now - lastPrivateTypingUpdate < 2000) return; // throttle 2s
  lastPrivateTypingUpdate = now;
  try {
    await setDoc(doc(db, 'privateChats', currentPrivateChatId, 'typing', currentUser.uid), {
      uid: currentUser.uid,
      displayName: currentUser.displayName || '',
      updatedAt: serverTimestamp()
    }, { merge: true });
    if (!privateTypingInterval) privateTypingInterval = setInterval(() => {
      setDoc(doc(db, 'privateChats', currentPrivateChatId, 'typing', currentUser.uid), {
        uid: currentUser.uid,
        displayName: currentUser.displayName || '',
        updatedAt: serverTimestamp()
      }, { merge: true }).catch(() => {});
    }, 3000);
  } catch (e) {}
}

async function removePrivateTyping(chatId) {
  if (!currentUser || !chatId) return;
  try { await deleteDoc(doc(db, 'privateChats', chatId, 'typing', currentUser.uid)); } catch (e) {}
  stopPrivateTypingUpdates();
}

function stopPrivateTypingUpdates() {
  if (privateTypingInterval) { clearInterval(privateTypingInterval); privateTypingInterval = null; }
}

function startPrivateTypingListener(chatId) {
  // unsubscribe possible previous listener on private typing by re-creating listener tied to current chatId
  const q = collection(db, 'privateChats', chatId, 'typing');
  onSnapshot(q, (snap) => {
    const nowTs = Timestamp.now();
    const active = [];
    snap.forEach(s => {
      const d = s.data();
      if (d.updatedAt && (nowTs.seconds - d.updatedAt.seconds) <= TYPING_EXPIRY_SECONDS) {
        if (d.uid !== (currentUser && currentUser.uid)) active.push({ uid: d.uid, displayName: d.displayName || d.uid });
      }
    });
    renderTyping(privateTypingDiv, active);
  }, (err) => {
    // ignore
  });
}

/* Rendering typing indicator: show up to 2 names, and "and N others are typing" */
function renderTyping(container, activeArray) {
  if (!activeArray || activeArray.length === 0) {
    container.style.display = 'none';
    container.innerHTML = '';
    return;
  }
  container.style.display = 'flex';
  const names = activeArray.map(a => a.displayName || a.uid);
  const firstTwo = names.slice(0,2);
  const restCount = Math.max(0, names.length - 2);
  let text = '';
  if (names.length === 1) text = `${firstTwo[0]} is typing`;
  else if (names.length === 2) text = `${firstTwo[0]} and ${firstTwo[1]} are typing`;
  else text = `${firstTwo[0]}, ${firstTwo[1]} and ${restCount} others are typing`;
  container.innerHTML = `<span class="typing-names">${escapeHtml(text)}</span><span class="dots"><span></span><span></span><span></span></span>`;
}

/* utility: smooth scroll to bottom of a container */
function scrollToBottom(el) {
  if (!el) return;
  el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
}

/* Helpers */
function escapeHtml(s) {
  if (!s) return '';
  return String(s).replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[c]);
}

/* Initial placeholders */
publicMessagesDiv.innerHTML = '<div class="muted">Sign in to chat.</div>';
usersList.innerHTML = '<div class="muted">Sign in to see active users.</div>';
dmList.innerHTML = '<div class="muted">Sign in to see DMs.</div>';

</script>
</body>
</html>
